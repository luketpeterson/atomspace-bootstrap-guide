
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Programming with Atomese &#8212; Luke&#39;s Atomspace Quickstart Guide 0.0.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Evaluation and Truth Values" href="04_evaluation_and_truth_values.html" />
    <link rel="prev" title="Structured Knowledge &amp; Simple Queries" href="02_representing_knowledge.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p id="atomese-programming">Previous Chapter: <a class="reference internal" href="02_representing_knowledge.html#representing-knowledge"><span class="std std-ref">Structured Knowledge</span></a></p>
<div class="section" id="programming-with-atomese">
<h1>Programming with Atomese<a class="headerlink" href="#programming-with-atomese" title="Permalink to this headline">¶</a></h1>
<p>In the previous chapter, we introduced Atomspace queries and a little bit about the execution model with <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code>.
Now we’ll go deeper into some more of the program-flow constructs that allow Atomese to behave like a complete programming language.</p>
<p>In this upcoming chapter, we’ll deal with Atomese approaches to conditionals, code factoring (i.e. functions), and looping.</p>
<p>If you are steeped in procedural programming, like I am, there are things about the Atomspace execution model that will require you to turn your brain inside-out.
On the other hand, if you come from a <a class="reference external" href="https://en.wikipedia.org/wiki/Lambda_calculus">Lambda Calculus</a> or <a class="reference external" href="https://en.wikipedia.org/wiki/Functional_programming">Functional Programming</a> background then, lucky you!
This next parts will be a lot easier to wrap your head around.</p>
<p>The Atomspace is different from procedural programming languages insofar as there isn’t a program counter as I typically understand it.
You can’t “follow” the execution in a sequential fashion the way you might be able to in other languages.
Under the hood, obviously, it’s software running on a microprocessor so there has to be sequential instruction-flow at some level, but it’s abstracted away from you and trying to follow it is counter-productive to understanding how to effectively use the Atomspace.</p>
<div class="section" id="conditional-expressions">
<h2>Conditional Expressions<a class="headerlink" href="#conditional-expressions" title="Permalink to this headline">¶</a></h2>
<p>In the previous chapter, we used a <code class="code docutils literal notranslate"><span class="pre">MeetLink</span></code> and <code class="code docutils literal notranslate"><span class="pre">QueryLink</span></code> to query the “weight_in_kg” of “Fido the Dog”,
and used a different query to find all dogs (actually all atoms) heavier than 10kg.
But how can we cause a different action to be taken, depending on whether or not Fido is heavier than 10kg?</p>
<p>More generally, how do we compose a conditional expression in Atomese?</p>
<p>Let’s start with a simpler conditional.  We’ll use a <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> like this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">CondLink</span>
        <span class="p">(</span><span class="nf">GreaterThan</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>When you execute the Scheme snippet above, you will see <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">ConceptNode</span></span> <span class="s"><span class="pre">“Yes”</span></span><span class="p"><span class="pre">)</span></span></code> because 2 is indeed greater than 1.
Simple enough.  <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> takes either 2 or 3 atoms as arguments.</p>
<p>The first is the <em>conditional</em> predicate atom.  Something that will evaluate to true or false.  There is a lot more to say about this later.
For now, just remember that <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> predicates must be 100% true or they will be considered false.</p>
<p>Argument 2 is the <em>consequent</em> atom, or as I like to think of it, the expression after the <strong>then</strong> keyword in other languages.  Optionally, for argument 3, you can supply a <em>default</em> atom, which is basically the <strong>else</strong> expression, to be executed if the conditional evaluates to false.</p>
<p>Building on that, let’s compare Fido’s weight rather than just comparing some constants.  First we need to bring Fido back into the Atomspace (assuming you’ve cleared things out since last chapter’s exercises).</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">fidos_weight_link</span>
    <span class="p">(</span><span class="nf">ListLink</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Fido the Dog&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;weight_in_kg&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="p">(</span><span class="nf">StateLink</span>
    <span class="nv">fidos_weight_link</span>
    <span class="p">(</span><span class="nf">NumberNode</span> <span class="mf">12.5</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Now we need a predicate that will query for Fido’s weight, and evaluate to true if he’s heavier than 10kg.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">fido_is_big?</span>
    <span class="p">(</span><span class="nf">SatisfactionLink</span>
        <span class="p">(</span><span class="nf">AndLink</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="nv">fidos_weight_link</span>
                <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;dogs_weight_node&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">GreaterThan</span>
                <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;dogs_weight_node&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">10</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Earlier I promised I wouldn’t drop a new atom or other construct on you without at least attempting to demystify it.  <code class="code docutils literal notranslate"><span class="pre">SatisfactionLink</span></code> is yet another query link type.
Fundamentally it’s just like <code class="code docutils literal notranslate"><span class="pre">MeetLink</span></code>, <code class="code docutils literal notranslate"><span class="pre">GetLink</span></code>, <code class="code docutils literal notranslate"><span class="pre">QueryLink</span></code>, and <code class="code docutils literal notranslate"><span class="pre">BindLink</span></code>.</p>
<p>The main feature that sets <code class="code docutils literal notranslate"><span class="pre">SatisfactionLink</span></code> apart is that it evaluates to a TruthValue.  True, aka <code class="code scheme docutils literal notranslate"><span class="nv"><span class="pre">stv</span></span><span class="p"><span class="pre">(</span></span><span class="mi"><span class="pre">1</span></span><span class="o"><span class="pre">,</span></span> <span class="mi"><span class="pre">1</span></span><span class="p"><span class="pre">)</span></span></code>, if the expression could be matched in the Atomspace, and false, aka <code class="code scheme docutils literal notranslate"><span class="nv"><span class="pre">stv</span></span><span class="p"><span class="pre">(</span></span><span class="mi"><span class="pre">0</span></span><span class="o"><span class="pre">,</span></span> <span class="mi"><span class="pre">1</span></span><span class="p"><span class="pre">)</span></span></code>, if not.
There is a lot to say about TruthValues, and we’ll get there soon.  For now you can think of them as Boolean True/False or Yes/No values, just know that there is a lot more to them.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">SatisfactionLink</span></code> is actually the basic building-block from which all of the other query link types are constructed.</p>
</div>
<p>Finally, let’s use our new <code class="code scheme docutils literal notranslate"><span class="nv"><span class="pre">fido_is_big?</span></span></code> predicate in a <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> atom.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">CondLink</span>
        <span class="nv">fido_is_big?</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Executing that should get you a resounding <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">ConceptNode</span></span> <span class="s"><span class="pre">“Yes”</span></span><span class="p"><span class="pre">)</span></span></code>!</p>
</div>
<div class="section" id="using-putlink-to-modify-the-atomspace">
<h2>Using PutLink to Modify the AtomSpace<a class="headerlink" href="#using-putlink-to-modify-the-atomspace" title="Permalink to this headline">¶</a></h2>
<p>Now, let’s use the result of our conditional to update some state in the Atomspace.
Recall how, a few chapters ago, we used a <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> to create an exclusive link that can only have one result for a given atom.
Here, we will assign a <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> result depending on a <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> conditional execution.</p>
<p>To do this, we will use <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>.  You can think of <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> as the assignment operator of Atomese, akin to “<strong>=</strong>” or “<strong>:=</strong>” in other languages.
Here in our example, we set the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> association of <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Predicate</span></span> <span class="s"><span class="pre">“conditional_result”</span></span><span class="p"><span class="pre">)</span></span></code> with one of two possible <code class="code docutils literal notranslate"><span class="pre">ConceptNode</span></code> atoms.</p>
<p>In reality, the comparison of <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> to the assignment operator is flawed because of enormous fundamental differences between the Atomspace and the traditional precedural programming language execution model.
The <a class="reference external" href="https://wiki.opencog.org/w/PutLink">OpenCog PutLink documentation</a> more accurately describes <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> as a <em>Beta Redex</em>, but without a Lambda Calculus background that didn’t connect for me.
So, I found the analogy to assignment to be a useful way of bootstrapping my understanding, not only of <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> itself, but the process of learning about <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> gave me a deeper understanding of the Atomspace as a whole.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">PutLink</span>
        <span class="p">(</span><span class="nf">CondLink</span>
            <span class="p">(</span><span class="nf">TrueLink</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;result_placeholder&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;result_placeholder&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>As you probably expected, running the Scheme snippet above produces this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">StateLink</span>
    <span class="p">(</span><span class="nf">PredicateNode</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">ConceptNode</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>So now the one and only <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> associated with <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">PredicateNode</span></span> <span class="s"><span class="pre">“conditional_result”</span></span><span class="p"><span class="pre">)</span></span></code> points to <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">ConceptNode</span></span> <span class="s"><span class="pre">“Yes”</span></span><span class="p"><span class="pre">)</span></span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">TrueLink</span></code> and its mirror-twin <code class="code docutils literal notranslate"><span class="pre">FalseLink</span></code> are atoms that always evaluate to true (or false).  As used above, it’s equivalent to saying “if (true)” in another language, and thus it gives me a concise way to demonstrate the behavior of the <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> atom.</p>
</div>
<p>This <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> expression appears fairly simple but some of the behavior is a bit subtle and non-obvious, and it tripped me up badly at first.
Understanding <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> is critical to internalizing a key Atomspace concept, i.e. learning how to think about atoms that represent data aka program state vs. atoms that represent operations that can affect the data.
In another programming language we would call these “data” and “code”.</p>
<p>Remember both kinds of atoms live in the Atomspace, and there isn’t a simple rule about whether an atom is “data” or it’s “code”.  Often it can feel like everything is all mixed together.
This is a source of tremendous flexibility, but remember, with great power comes great responsibility ;-)</p>
<p>So back to <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>.  Like the name suggests, it “Puts” atoms into the Atomspace.
The simplest valid <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> I could compose looks like this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">PutLink</span>
        <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;atom_placeholder&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;The Atom We Are Putting In&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>But hold on…  What’s the point?  Isn’t that identical to just: <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Concept</span></span> <span class="s"><span class="pre">“The</span> <span class="pre">Atom</span> <span class="pre">We</span> <span class="pre">Are</span> <span class="pre">Putting</span> <span class="pre">In”</span></span><span class="p"><span class="pre">)</span></span></code>?</p>
<p>Yes.  Yes it is.  <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> is not the only way to put atoms into the Atomspace.
We’ve been putting atoms in the Atomspace since the very first example in this guide.
So why do we need <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> then?</p>
<div class="section" id="ungrounded-expressions-can-represent-latent-code">
<h3>Ungrounded Expressions can Represent “Latent Code”<a class="headerlink" href="#ungrounded-expressions-can-represent-latent-code" title="Permalink to this headline">¶</a></h3>
<p>Let’s look at what’s wrong with this naïve attempt to set our result <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> from the first example.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">CondLink</span>
        <span class="p">(</span><span class="nf">TrueLink</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">StateLink</span>
            <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">StateLink</span>
            <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Try it!  Did it do what you expected?  I know I was puzzled when I encountered this behavior.  Actually “annoyed” and “frustrated” are more accurate words.</p>
<p>A clue to what is happening can be found by dropping the <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code>, and just observing what happens when the <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> and all its referenced atoms are added to the Atomspace.
Notice that the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> connecting <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Predicate</span></span> <span class="s"><span class="pre">“conditional_result”</span></span><span class="p"><span class="pre">)</span></span></code> to <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Concept</span></span> <span class="s"><span class="pre">“Yes”</span></span><span class="p"><span class="pre">)</span></span></code> is gone altogether.
Remember that the act of creating a <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> removes a prior extant <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> with the same target.</p>
<p>This left me scratching my head for a minute.  I was stuck in the mindset that I was just inputting code, and the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> behavior would only be triggered when the code actually executed.  Wrong!</p>
<p>As I inputted the first arm of the <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code>, I actually assigned the result to “Yes” by creating the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code>.
Then, when I inputted the second arm, I re-assigned the result to “No”, by creating the new <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code>, thus triggering the old one to be destroyed.</p>
<p>Finally, when I executed the <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code>, there was no “else” clause atom, because the “then” clause atom had disappeared and so the former “else” clause atom became argument 2, and was interpreted as the “then” clause atom.
So the atom I actually executed looked like this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">CondLink</span>
    <span class="p">(</span><span class="nf">TrueLink</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">StateLink</span>
        <span class="p">(</span><span class="nf">PredicateNode</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">ConceptNode</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Basically <code class="code docutils literal notranslate"><span class="pre">if</span> <span class="pre">(true)</span> <span class="pre">{</span> <span class="pre">result</span> <span class="pre">=</span> <span class="pre">No;</span> <span class="pre">}</span></code>.  Oops.</p>
<p>So what’s the solution?</p>
<p>We introduced ungrounded vs. grounded expressions last chapter when discussing queries.
I remember saying (typing) “Think of a grounded expression as a statement and an ungrounded expression as a question.”</p>
<p>Now I’ll add a bit more nuance.  You can also think of an ungrounded expression as a <strong>Hypothetical</strong> or <strong>Abstract</strong> statement.
As long as an expression is ungrounded, it doesn’t really say anything specific or concrete.</p>
<p>So in terms of the example, the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> atoms we want to input say “Connect <em>something</em> with ‘Yes’” and “Connect <em>something</em> with ‘No’”.
But without that <em>something</em> being a specific concrete atom, the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> can’t do its behavior to ensure uniqueness and thus both <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> atoms are allowed to exist at the same time.</p>
<p>That’s where <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> comes in.  When <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> is executed, the ungrounded expression is grounded using the atom(s) supplied to <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>.
In the case of the example, that is <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Predicate</span></span> <span class="s"><span class="pre">“conditional_result”</span></span><span class="p"><span class="pre">)</span></span></code> .  And the atoms of the newly grounded expression are put into the Atomspace.</p>
</div>
<div class="section" id="grounding-a-deletelink-removes-an-atom">
<h3>Grounding a DeleteLink Removes an Atom<a class="headerlink" href="#grounding-a-deletelink-removes-an-atom" title="Permalink to this headline">¶</a></h3>
<p>We just saw how grounding a <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> can cause another conflicting <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> atom to be deleted if they share the same target atom.
This is a special case of a general behavior.  To illustrate that, I’ll introduce the <code class="code docutils literal notranslate"><span class="pre">DeleteLink</span></code> atom.</p>
<p>As long as the <code class="code docutils literal notranslate"><span class="pre">DeleteLink</span></code> remains ungrounded, it doesn’t to anything.
But the instant it is grounded, it ceases to exist, and takes whatever atoms it references out along with it.</p>
<p>Consider this Scheme snippet:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">hello</span> <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Here I am!&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">delete_me</span>
    <span class="p">(</span><span class="nf">PutLink</span>
        <span class="p">(</span><span class="nf">DeleteLink</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;the_concept&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="nv">hello</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>We just defined two scheme symbols: <code class="code docutils literal notranslate"><span class="pre">hello</span></code> and <code class="code docutils literal notranslate"><span class="pre">delete_me</span></code>.  Let’s prove <code class="code docutils literal notranslate"><span class="pre">hello</span></code> exists by having a look.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">display </span><span class="nv">hello</span><span class="p">)</span>
</pre></div>
</div>
<p>Yup.  Just where we left it.
We can also look at <code class="code docutils literal notranslate"><span class="pre">delete_me</span></code>, and we will see it contains an ungrounded <code class="code docutils literal notranslate"><span class="pre">DeleteLink</span></code> expression.</p>
<p>But what happens when we execute <code class="code docutils literal notranslate"><span class="pre">delete_me</span></code>?</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span> <span class="nv">delete_me</span><span class="p">)</span>
</pre></div>
</div>
<p>Well… We just annihilated the atom referenced by <code class="code docutils literal notranslate"><span class="pre">hello</span></code>.  To prove it, we’ll try to display it again.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">display </span><span class="nv">hello</span><span class="p">)</span>
</pre></div>
</div>
<p>So sad. :-(  We now get <code class="code docutils literal notranslate"><span class="pre">#&lt;Invalid</span> <span class="pre">handle&gt;</span></code>.</p>
<p>Of course, deleting a pre-specified atom using a <code class="code docutils literal notranslate"><span class="pre">DeleteLink</span></code> inside a <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> isn’t really any more useful than just declaring the <code class="code docutils literal notranslate"><span class="pre">DeleteLink</span></code> directly, and skipping all the <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> machinations.
We could have just done this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span> <span class="p">(</span><span class="nf">DeleteLink</span> <span class="nv">hello</span><span class="p">))</span>
</pre></div>
</div>
<p>However, next, we’ll cover how to query for atoms inside a <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>, so we’ll be able to do things like deleting all atoms returned by a query, for example.</p>
<p>At some point, I recommend exploring the Atomspace execution model further by going through the <a class="reference external" href="https://github.com/opencog/atomspace/blob/master/examples/atomspace/assert-retract.scm">“assert-retract.scm” OpenCog example</a>.
In particular, understanding the mechanics of <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> and <code class="code docutils literal notranslate"><span class="pre">DeleteLink</span></code> will help you understand what really happens when you invoke <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code>.</p>
</div>
<div class="section" id="finding-atoms-with-a-query-inside-a-putlink">
<h3>Finding Atoms with a Query Inside a PutLink<a class="headerlink" href="#finding-atoms-with-a-query-inside-a-putlink" title="Permalink to this headline">¶</a></h3>
<p>To implement any complex behavior beyond the trivial toy examples we’ve seen so far,
like our conditional above that branched based on a constant, we need to operate on data from the Atomspace.</p>
<p>Consider a simple counter that might be written in C like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>How would that look in Atomese?</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">State</span> <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Number</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">PutLink</span>
        <span class="p">(</span><span class="nf">State</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">PlusLink</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_num&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">MeetLink</span>
            <span class="p">(</span><span class="nf">State</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_num&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>As you can see in both C and Atomese, we begin by declaring <code class="code docutils literal notranslate"><span class="pre">counter</span></code> and initially setting it to 0 (Zero).
In a way, a declaration with an initial value is like an assignment, but you couldn’t write much of a program using only declarations in C, and that’s also true in Atomese.</p>
<p>So, looking at the interesting part of the example, we supplied two atoms to <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>.
We can think of the first argument as being like the “R-Value” and the second argument as being like the “L-Value”.
That’ll mean something if you’ve spent significant time working through gcc errors.
If not, consider yourself fortunate for avoiding that particular drain of life energy.</p>
<p>Basically, the first argument is the expression to the right of the equal-sign in the assignment.
From our C example, that would be <code class="code c docutils literal notranslate"><span class="n"><span class="pre">counter</span></span> <span class="o"><span class="pre">+</span></span> <span class="mi"><span class="pre">1</span></span></code>.  Think of the R-Value as “what” is being assigned.</p>
<p>The second argument to <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> is the part of the assignment to the left of the equal side.
From our C example, that would be <code class="code c docutils literal notranslate"><span class="n"><span class="pre">counter</span></span></code>.  Think of the L-Value as “where” you are assigning to.</p>
<p>Again, this is a flawed comparison with the assignment operation in C, so don’t try and stretch the analogy too far.
For example, you could change the ConceptNode in the first expression, so a totally different atom would be created by executing the <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>
Therefore, it’s more accurate to say the second argument matches existing atoms, providing concrete meanings to the <code class="code docutils literal notranslate"><span class="pre">VariableNode</span></code> atoms in the first argument,
While the first argument is a template for the new atoms to insert into the Atomspace, after that template is grounded in terms of the second argument.</p>
<p>Coming full circle, <code class="code docutils literal notranslate"><span class="pre">QueryLink</span></code> and <code class="code docutils literal notranslate"><span class="pre">BindLink</span></code> are actually implemented using PutLink.
The increment example above is functionally equivalent to this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">QueryLink</span>
        <span class="p">(</span><span class="nf">State</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_num&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">State</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">PlusLink</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_num&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference external" href="https://github.com/opencog/atomspace/blob/master/examples/atomspace/get-put.scm">“get-put.scm” OpenCog example</a>
Further explores <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> and demonstrates exactly how a <code class="code docutils literal notranslate"><span class="pre">BindLink</span></code> can be composed from a <code class="code docutils literal notranslate"><span class="pre">GetLink</span></code> and a <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>.
I recommend going through that example as well as the <a class="reference external" href="https://github.com/opencog/atomspace/blob/master/examples/atomspace/bindlink.scm">“bindlink.scm” example</a>.</p>
</div>
</div>
<div class="section" id="defines-schemas-lambdas-and-functions-in-atomese">
<h2>Defines, Schemas, Lambdas and Functions in Atomese<a class="headerlink" href="#defines-schemas-lambdas-and-functions-in-atomese" title="Permalink to this headline">¶</a></h2>
<p>Up until now, we’ve been using Scheme’s <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">define</span></span><span class="p"><span class="pre">)</span></span></code> mechanism to as a way to get a symbolic reference to an atom we intend to use later.
But this mechanism has some limitations that we’re about to cover, not to mention its reliance on Scheme.
Remember the Atomspace can theoretically be accessed from other non-Scheme environments.</p>
<p>In this section we’re going to introduce some code segmentation and organization primitives that are native to Atomese.</p>
<p>Let’s being with Atomese’s own version of <code class="code docutils literal notranslate"><span class="pre">define</span></code>, the <code class="code docutils literal notranslate"><span class="pre">DefineLink</span></code>.  Here’s an example:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">Define</span> <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;five&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">NumberNode</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
<p>We just introduced two new atom types: <code class="code docutils literal notranslate"><span class="pre">DefineLink</span></code> and <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code>.  <code class="code docutils literal notranslate"><span class="pre">DefineLink</span></code> gives a name to something else.  That’s it.</p>
<p>The first argument to a <code class="code docutils literal notranslate"><span class="pre">DefineLink</span></code> needs to be a “naming” node.
There are 3 special “naming” node types: <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code>, <code class="code docutils literal notranslate"><span class="pre">DefinedPredicateNode</span></code>, and <code class="code docutils literal notranslate"><span class="pre">DefinedTypeNode</span></code>.
We’ll cover the latter two in due course, but here we’ll focus on <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code>.
The second atom provided to <code class="code docutils literal notranslate"><span class="pre">DefineLink</span></code> is the definition body.  In our case, it is just a simple <code class="code docutils literal notranslate"><span class="pre">NumberNode</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code> is the most general of the “naming” node types.  A <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code> can give a name to any other atom.</p>
<p>We can now use our <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code> as we would use the atom it represents…  Almost.
This example below does exactly what you think it should do.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">State</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;five&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>But without the <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code>, the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> connects <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Concept</span></span> <span class="s"><span class="pre">“counter”</span></span><span class="p"><span class="pre">)</span></span></code> to <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">DefinedSchemaNode</span></span> <span class="s"><span class="pre">“five”</span></span><span class="p"><span class="pre">)</span></span></code>, and not to <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">NumberNode</span></span> <span class="mi"><span class="pre">5</span></span><span class="p"><span class="pre">)</span></span></code>.
The <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code> will be replaced by the node it represents, but only when it is reduced by executing it.
Think of it like a <code class="code c docutils literal notranslate"><span class="k"><span class="pre">const</span></span></code> in C, not like a pre-processor <code class="code c docutils literal notranslate"><span class="cp"><span class="pre">#define</span></span></code>.</p>
<div class="section" id="basic-subroutines">
<h3>Basic Subroutines<a class="headerlink" href="#basic-subroutines" title="Permalink to this headline">¶</a></h3>
<p><code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code> can also be used to define subroutines.  By subroutine I mean a block of code you can call, but where there are no function arguments.
The expectation is that all communication between the subroutine and the caller happens by way of global program state.
Subroutines are just a way to dispatch one chunk of code from a different place in the program.
Most modern programming languages don’t even have subroutines because they can lead to hideous spaghetti code and functions with arguments reduce to subroutines in the case where no arguments are needed.
If you’ve written assembly code by hand or worked with a very old language like <a class="reference external" href="https://en.wikipedia.org/wiki/Integer_BASIC">Integer BASIC</a>, you’ll certainly appreciate why subroutines are insufficient to architect a complex piece of software.</p>
<p>All that said, subroutines are simpler than functions so let’s start there.
Here is an example:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchemaNode</span> <span class="s">&quot;turn_on_switch&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">PutLink</span>
        <span class="p">(</span><span class="nf">State</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;switch_placeholder&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;On&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Global Switch&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>We can call it like this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span> <span class="p">(</span><span class="nf">DefinedSchemaNode</span> <span class="s">&quot;turn_on_switch&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>That’s it.  The <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">DefinedSchemaNode</span></span> <span class="s"><span class="pre">“turn_on_switch”</span></span><span class="p"><span class="pre">)</span></span></code> takes the place of the whole <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> and all its dependent atoms.</p>
</div>
<div class="section" id="lambdalink-lets-you-pass-function-arguments">
<h3>LambdaLink Lets you Pass Function Arguments<a class="headerlink" href="#lambdalink-lets-you-pass-function-arguments" title="Permalink to this headline">¶</a></h3>
<p>The difference between subroutines vs. procedures and functions are the arguments that can be passed.
<code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code> is the mechanism for defining functions in Atomese, and specifying the arguments that can be passed in.</p>
<p>Here is an example function that squares the incoming <code class="code docutils literal notranslate"><span class="pre">NumberNode</span></code> argument:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchemaNode</span> <span class="s">&quot;square&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">LambdaLink</span>
        <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">TimesLink</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>So there’s our function.  It takes a <code class="code docutils literal notranslate"><span class="pre">NumberNode</span></code> and squares it.
The first argument to <code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code> is <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">VariableNode</span></span> <span class="s"><span class="pre">“x”</span></span><span class="p"><span class="pre">)</span></span></code>.  This specifies that our function expects one argument, and we’re mapping that argument onto <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">VariableNode</span></span> <span class="s"><span class="pre">“x”</span></span><span class="p"><span class="pre">)</span></span></code>.</p>
<p>Now, how do we call it?</p>
<p>Well, unfortunately we can’t just <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code> it like the simple subroutine.  That will cause an error.
The reason is a little bit convoluted, but in essence, we need a seperate operation to pack up the arguments and bind them to the <code class="code docutils literal notranslate"><span class="pre">VariableNode</span></code> atoms used inside the fucntion, and then dispatch the function execution.
That “dispatch” process is handled by the <code class="code docutils literal notranslate"><span class="pre">ExecutionOutputLink</span></code> atom.
Atomese is very “assembly-language-like”, so very little is magically done for you, as might happen in higher-level languages.</p>
<p>We call it like this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">ExecutionOutputLink</span>
        <span class="p">(</span><span class="nf">DefinedSchemaNode</span> <span class="s">&quot;square&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">NumberNode</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The first argument is our <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code>, and the second atom argument is the parameter we are passing to our function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>QUESTION FOR SOMEONE SMARTER THAN ME.  I don’t fully understand why the below snippet doesn’t fully reduce when executed.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">State</span> <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;increment&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">LambdaLink</span>
        <span class="p">(</span><span class="nf">VariableList</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">PutLink</span>
            <span class="p">(</span><span class="nf">State</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Plus</span>
                    <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_num&quot;</span><span class="p">)</span>
                    <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">MeetLink</span>
                <span class="p">(</span><span class="nf">State</span>
                    <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
                    <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_num&quot;</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">ExecutionOutputLink</span>
        <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;increment&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">List</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>RESULT</strong></p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="nv">$1</span> <span class="nv">=</span> <span class="p">(</span><span class="nf">StateLink</span>
<span class="p">(</span><span class="nf">ConceptNode</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">PlusLink</span>
    <span class="p">(</span><span class="nf">NumberNode</span> <span class="s">&quot;2&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">NumberNode</span> <span class="s">&quot;1&quot;</span><span class="p">)))</span>
</pre></div>
</div>
<p><strong>EXPECTED RESULT</strong></p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="nv">$1</span> <span class="nv">=</span> <span class="p">(</span><span class="nf">StateLink</span>
<span class="p">(</span><span class="nf">ConceptNode</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">NumberNode</span> <span class="s">&quot;3&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>Yet, if I remove the LambdaLink &amp; ExecutionOutputLink, it does what I would expect and the PutLink fully reduces.</p>
</div>
</div>
<div class="section" id="typed-variables-and-variablelists-as-arguments">
<h3>Typed Variables and VariableLists as Arguments<a class="headerlink" href="#typed-variables-and-variablelists-as-arguments" title="Permalink to this headline">¶</a></h3>
<p><code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code> takes a single atom to specify its argument, but what if we want to pass multiple arguments to a function?
Enter the <code class="code docutils literal notranslate"><span class="pre">VariableList</span></code> atom.
A <code class="code docutils literal notranslate"><span class="pre">VariableList</span></code>, as the name would suggest, is an ordered list to define multiple <code class="code docutils literal notranslate"><span class="pre">VariableNode</span></code> atoms, and thus multiple function arguments.</p>
<p>You can use it with a <code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code>, as in the example below, where I’ve reimplemented simple multiplication using <code class="code docutils literal notranslate"><span class="pre">TimesLink</span></code>.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;multiply&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">LambdaLink</span>
        <span class="p">(</span><span class="nf">VariableList</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;y&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">TimesLink</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;y&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>And we use a <code class="code docutils literal notranslate"><span class="pre">ListLink</span></code> to pass the arguments, when we want to call it.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">ExecutionOutputLink</span>
        <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;multiply&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">List</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>If your list doesn’t have enough arguments to match the <code class="code docutils literal notranslate"><span class="pre">VariableList</span></code> of the <code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code> that you are calling, then it will cause an error.
On the other hand, if you pass additional extraneous arguments they will be silently ignored.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">VariableList</span></code> is one type of <code class="code docutils literal notranslate"><span class="pre">Connector</span></code>.  <code class="code docutils literal notranslate"><span class="pre">Connector</span></code> atoms are used to declare which atoms may be linked with which other atoms.  They are key to specifying custom grammars, which we will cover later on.</p>
</div>
<p>We have been using “naked” unadorned <code class="code docutils literal notranslate"><span class="pre">VariableNode</span></code> atoms, which can map onto any other atom whatsoever, irrespective of the atom’s type.
In some situations we may want to constrain the types of atoms that our function accept as arguments.
This is done with a <code class="code docutils literal notranslate"><span class="pre">TypedVariableLink</span></code>.</p>
<p>Here is the “multiply” function from above, but using <code class="code docutils literal notranslate"><span class="pre">TypedVariableLink</span></code> atoms to declare that the parameters should be <code class="code docutils literal notranslate"><span class="pre">NumberNode</span></code> atoms.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;multiply&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">LambdaLink</span>
        <span class="p">(</span><span class="nf">VariableList</span>
            <span class="p">(</span><span class="nf">TypedVariableLink</span>
                <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">TypeNode</span> <span class="s">&quot;NumberNode&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">TypedVariableLink</span>
                <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;y&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">TypeNode</span> <span class="s">&quot;NumberNode&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">TimesLink</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;y&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">TypeNode</span></code> is an atom type that represents an atom type.  Whoa… that’s meta.
It can refer to any of the built-in atom types we’ve used so far; in addition, new types can be defined.
In a later chapter we’ll get deeper into Signatures and creating new atom types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>QUESTION FOR SOMEBODY SMARTER THAN ME.  What is <code class="code docutils literal notranslate"><span class="pre">TypedVariableLink</span></code> actually useful for when used in a <code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code>?  It seems to be ignored when executing lambdas.  I see how it gives extra criteria when matching.  Am I missing something?</p>
</div>
<p>Finally, I should mention that the variable declaration features of Atomese aren’t just for <code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code> and functions.</p>
<p><code class="code docutils literal notranslate"><span class="pre">VariableList</span></code> and <code class="code docutils literal notranslate"><span class="pre">TypedVariableLink</span></code> can be used with any of the query link types, such as <code class="code docutils literal notranslate"><span class="pre">MeetLink</span></code>, <code class="code docutils literal notranslate"><span class="pre">QueryLink</span></code>, <code class="code docutils literal notranslate"><span class="pre">SatisfactionLink</span></code>, etc.
Often including a <code class="code docutils literal notranslate"><span class="pre">VariableList</span></code> in a match expression is optional, because the variables can be inferred from the expression itself.
When there is any ambiguity, however, including a <code class="code docutils literal notranslate"><span class="pre">VariableList</span></code> is required.</p>
<p>In addition, including a <code class="code docutils literal notranslate"><span class="pre">TypedVariableLink</span></code> around a <code class="code docutils literal notranslate"><span class="pre">VariableNode</span></code> in a query can help narrow down the possible matches that can satisfy the query.</p>
</div>
</div>
<div class="section" id="looping-with-tail-recursion">
<h2>Looping with Tail Recursion<a class="headerlink" href="#looping-with-tail-recursion" title="Permalink to this headline">¶</a></h2>
<p>Atomese doesn’t have loops, in the way most iterative programming languages do.  Like most pure functional languages, looping behavior is done through recursion.
To utilize recursion, you make the loop body into a function, and then you have the function call itself.
Every recursive function fundamentally has two paths through it, one path that returns without further iterations, and one path that reduces the problem into a smaller problem and then calls itself to solve that new reduced problem.</p>
<p>It’s mathematically proven (By Alan Turing himself) than any algorithm that can be expressed with iteration can also be expressed with recursion.
However, this says nothing about the gymnastics that are needed for the implementation of a particular algorithm.
In any case, this is not the point of the guide and the topic is thoroughly covered elsewhere.</p>
<p>The “Tail” in Tail Recursion means that self-calling is the very last thing the function does before exiting.
Therefore, there is no need to retain the execution state for the “parent” function.
Traditional recursion has a bad reputation for consumption of stack memory, because each iteration allocates a new stack frame.  Tail recursion makes this a non-issue.
In fact, in many programming languages, tail recursion has been shown to be as fast as iterative looping.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Atomese is not a language designed for execution speed, so don’t expect your Atomese code to be fast compared to anything written in a more traditional compiled language, or even an interpreted scripting language.</p>
</div>
<p>Below is an example that uses tail recursion to increment a counter repeatedly.
This could stand-in for a for-loop.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;loop_body&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">LambdaLink</span>
        <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;iterator&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">CondLink</span>
            <span class="c1">; Check to see if the &quot;iterator&quot; parameter is &gt; 4</span>
            <span class="p">(</span><span class="nf">GreaterThan</span>
                <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;iterator&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">4</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1">; If so, we are done,</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;iterator&quot;</span><span class="p">)</span>

            <span class="c1">; Here is the recursive call.  Call ourselves with iterator+1</span>
            <span class="p">(</span><span class="nf">ExecutionOutputLink</span>
                <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;loop_body&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Plus</span> <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;iterator&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>So the above function checks to see if the parameter is &gt; 4, and if not, calls itself with its parameter + 1.
This means it will be called 5 times in total.  Of course, it doesn’t actually do anything, so there is no point to the function.
It’s just a pure illustration of a recursive function implementing a loop.</p>
<p>Here is a <em>slightly</em> more useful example, a function to calculate the nth term of the Fibonacci sequence.
Of course this is far from optimal, given the order-n^2 execution difficulty for a sequence that should be order-n or better.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;fibonacci&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">LambdaLink</span>
        <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;n&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">CondLink</span>
            <span class="c1">; The 1st term is 0, so check to see if n is smaller than 2</span>
            <span class="p">(</span><span class="nf">GreaterThan</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;n&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1">; The 2nd term is 1, so check to see if n is smaller than 3</span>
            <span class="p">(</span><span class="nf">CondLink</span>
                <span class="p">(</span><span class="nf">GreaterThan</span>
                    <span class="p">(</span><span class="nf">Number</span> <span class="mi">3</span><span class="p">)</span>
                    <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;n&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1">; Otherwise, the nth term is fibbonacci(n-1) + fibbonacci(n-2)</span>
                <span class="c1">; Here are the recursive calls.</span>
                <span class="p">(</span><span class="nf">PlusLink</span>
                    <span class="p">(</span><span class="nf">ExecutionOutputLink</span>
                        <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;fibonacci&quot;</span><span class="p">)</span>
                        <span class="p">(</span><span class="nf">MinusLink</span> <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;n&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="p">)</span>
                    <span class="p">(</span><span class="nf">ExecutionOutputLink</span>
                        <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;fibonacci&quot;</span><span class="p">)</span>
                        <span class="p">(</span><span class="nf">MinusLink</span> <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;n&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>So here’s one way to improve our solution to only require n iterations as opposed to n^2.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;fibonacci_iterative&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">LambdaLink</span>
        <span class="p">(</span><span class="nf">VariableList</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;n&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;current_iter&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;current_term&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;previous_term&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">CondLink</span>
            <span class="c1">; If we&#39;re reached the end of the sequence, return &quot;current_term&quot;</span>
            <span class="p">(</span><span class="nf">Not</span> <span class="p">(</span><span class="nf">GreaterThan</span> <span class="c1">; not-greater-than is equivalent to less-than-or-equal-to</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;n&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;current_iter&quot;</span><span class="p">)</span>
            <span class="p">))</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;current_term&quot;</span><span class="p">)</span>

            <span class="c1">; Call ourselves recursively, to get the next term</span>
            <span class="p">(</span><span class="nf">ExecutionOutputLink</span>
                <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;fibonacci_iterative&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">List</span>
                    <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;n&quot;</span><span class="p">)</span>
                    <span class="p">(</span><span class="nf">Plus</span> <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;current_iter&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="p">(</span><span class="nf">Plus</span> <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;current_term&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;previous_term&quot;</span><span class="p">))</span>
                    <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;current_term&quot;</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This appraoch requires us to “seed” our sequence with some starting terms, but it is considerably more efficient than the earlier solution.
Here is an example of how we might call it:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">ExecutionOutputLink</span>
        <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;fibonacci_iterative&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">List</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">9</span><span class="p">)</span> <span class="c1">; We want the 9th term</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; We&#39;re passing in the 2nd term</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">; The 2nd term is 1</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">; The 1st term is 0</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>QUESTION FOR SOMEONE SMARTER THAN ME.  This is where I’d like to say “LambdaLink has this feature for default arguments”, but I couldn’t find anything like that… Does it exist?</p>
</div>
</div>
<div class="section" id="putlink-as-an-alternative-to-a-foreach-loop">
<h2>PutLink as an Alternative to a ForEach Loop<a class="headerlink" href="#putlink-as-an-alternative-to-a-foreach-loop" title="Permalink to this headline">¶</a></h2>
<p>As someone who grew up on procedural programming, the loop is second-nature to me.
And one of the most common reasons I reach for a loop is to do an operation for every item in a set or sequence.
The <code class="code docutils literal notranslate"><span class="pre">foreach</span></code> loop pattern, if you will.</p>
<p>But often, the order in which we process elements is irrelevant to the algorithm we are executing.
In this case, we really shouldn’t be thinking of a <code class="code docutils literal notranslate"><span class="pre">foreach</span></code> operation as a sequential loop at all.
We could just as easily think of it as the code taking a separate parallel branch for every item of the set we’re operating on.</p>
<p>This idea has been formalized recently as the <a class="reference external" href="https://en.wikipedia.org/wiki/MapReduce">Map-Reduce Pattern</a> and the fundamental concepts have been in use for decades before that.</p>
<p>In Atomese, this pattern can be implemented with <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>.
Let’s say we want to implement a “Sum-of-Squares” routine to compute the sum of the squared values of a set of numbers.
Following the Map-Reduce pattern, we’ll do it in two parts.</p>
<p>Below is a Scheme snippet to compute the square of each of series of numbers.
This is the “Map” part.  The result is another <code class="code docutils literal notranslate"><span class="pre">SetLink</span></code> containing the squares.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; Iterate over every number in the set and square it</span>
<span class="p">(</span><span class="k">define </span><span class="nv">squares_set</span>
    <span class="p">(</span><span class="nf">cog-execute!</span>
        <span class="p">(</span><span class="nf">PutLink</span>
            <span class="p">(</span><span class="nf">TimesLink</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_number&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_number&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">SetLink</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">3</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">4</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">5</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>As you can see, the first argument to <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> is ther operation to perform on each element, and the second argument is the set of elements.</p>
<p>We can examine the output set to prove to ourselves that everything followed our expectations.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">display </span><span class="nv">squares_set</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">SetLink</span></code> is an unordered link, so the order of the result elements probably won’t match the order of the input elements.</p>
</div>
<p>Now, for the “Reduce” part, we’ll use another <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> that calls a <code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code>.  Let’s start by resetting our counter to 0 (Zero).</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; Reset our &quot;sum&quot;</span>
<span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">SetValue</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;sum&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;numeric_value&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Number</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Now here is our function.  It increments “sum” by the number that’s passed in, and should execute on every element of the set:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; Function to add a number argument to the &quot;sum&quot;</span>
<span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;add_stuff&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">LambdaLink</span>
        <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_number&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">SetValue</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;sum&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;numeric_value&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">PlusLink</span>
                <span class="p">(</span><span class="nf">ValueOf</span>
                    <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;sum&quot;</span><span class="p">)</span>
                    <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;numeric_value&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_number&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>QUESTION FOR SOMEBODY SMARTER THAN ME.  Is there a better way to do this Map-Reduce pattern???  It seems wrong that we don’t tell the system that one PutLink has no inter-dependence and can execute in parallel and the other does have interdependence and needs to execute serially.  Unless there is some kind of code inspection going on it’s either not able to parallelize or it’s going to break when it tries to parallelize.  Both are not ideal.</p>
</div>
<p>Now let’s call it with the “squares_set” we created earlier.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; Sum up all the elements in the squares_set</span>
<span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">PutLink</span>
        <span class="p">(</span><span class="nf">ExecutionOutputLink</span>
            <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;add_stuff&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_number&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="nv">squares_set</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>And lastly, we retrieve our result by examining the <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Predicate</span></span> <span class="s"><span class="pre">“numeric_value”</span></span><span class="p"><span class="pre">)</span></span></code> value associated with the the <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Concept</span></span> <span class="s"><span class="pre">“sum”</span></span><span class="p"><span class="pre">)</span></span></code> atom.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span> <span class="p">(</span><span class="nf">ValueOf</span> <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;sum&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;numeric_value&quot;</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>QUESTION FOR SOMEBODY SMARTER THAN ME.  Why do I need a LambdaLink to make this execute???  Why won’t the below code work equivalently?</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="c1">; Iterate over every number in the set, and add it to the &quot;sum&quot;</span>
<span class="p">(</span><span class="nf">PutLink</span>
    <span class="p">(</span><span class="nf">SetValue</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;sum&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;numeric_value&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">PlusLink</span>
            <span class="p">(</span><span class="nf">ValueOf</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;sum&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;numeric_value&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_number&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="nv">squares_set</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>Next Chapter: <a class="reference internal" href="04_evaluation_and_truth_values.html#evaluation-and-truth-values"><span class="std std-ref">Evaluation and Truth Values</span></a></p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Luke's Atomspace Quickstart Guide</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="01_getting_oriented.html">Getting Oriented &amp; Basic Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_representing_knowledge.html">Structured Knowledge &amp; Simple Queries</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Programming with Atomese</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#conditional-expressions">Conditional Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-putlink-to-modify-the-atomspace">Using PutLink to Modify the AtomSpace</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ungrounded-expressions-can-represent-latent-code">Ungrounded Expressions can Represent “Latent Code”</a></li>
<li class="toctree-l3"><a class="reference internal" href="#grounding-a-deletelink-removes-an-atom">Grounding a DeleteLink Removes an Atom</a></li>
<li class="toctree-l3"><a class="reference internal" href="#finding-atoms-with-a-query-inside-a-putlink">Finding Atoms with a Query Inside a PutLink</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#defines-schemas-lambdas-and-functions-in-atomese">Defines, Schemas, Lambdas and Functions in Atomese</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basic-subroutines">Basic Subroutines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lambdalink-lets-you-pass-function-arguments">LambdaLink Lets you Pass Function Arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#typed-variables-and-variablelists-as-arguments">Typed Variables and VariableLists as Arguments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#looping-with-tail-recursion">Looping with Tail Recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#putlink-as-an-alternative-to-a-foreach-loop">PutLink as an Alternative to a ForEach Loop</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="04_evaluation_and_truth_values.html">Evaluation and Truth Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_logical_inferencing.html">Logical Inferencing <strong>INCOMPLETE!!</strong></a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="02_representing_knowledge.html" title="previous chapter">Structured Knowledge &amp; Simple Queries</a></li>
      <li>Next: <a href="04_evaluation_and_truth_values.html" title="next chapter">Evaluation and Truth Values</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Luke Peterson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/contents/03_atomese_programming.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Programming with Atomese &#8212; Luke&#39;s Atomspace Quickstart Guide 0.0.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Logical Inferencing" href="04_logical_inferencing.html" />
    <link rel="prev" title="Structured Knowledge &amp; Simple Queries" href="02_representing_knowledge.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p id="atomese-programming">Previous Chapter: <a class="reference internal" href="02_representing_knowledge.html#representing-knowledge"><span class="std std-ref">Structured Knowledge</span></a></p>
<div class="section" id="programming-with-atomese">
<h1>Programming with Atomese<a class="headerlink" href="#programming-with-atomese" title="Permalink to this headline">¶</a></h1>
<p>In the previous chapter, we introduced Atomspace queries and a little bit about the execution model with <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code>.
Now we’ll go deeper into some more of the program-flow constructs that allow Atomese to behave like a complete programming language.</p>
<p>In this upcoming chapter, we’ll deal with Atomese approaches to conditionals, code factoring (i.e. functions), and looping.
We will also cover the difference between the execution and the evaluation context.</p>
<p>If you are steeped in procedural programming, like I am, there are things about the Atomspace execution model that will require you to turn your brain inside-out.
On the other hand, if you come from a <a class="reference external" href="https://en.wikipedia.org/wiki/Lambda_calculus">Lambda Calculus</a> or <a class="reference external" href="https://en.wikipedia.org/wiki/Functional_programming">Functional Programming</a> background then, lucky you!
This next parts will be a lot easier to wrap your head around.</p>
<p>The Atomspace is different from procedural programming languages insofar as there isn’t a program counter as I typically understand it.
You can’t “follow” the execution in a sequential fashion the way you might be able to in other languages.
Under the hood, obviously, it’s software running on a microprocessor so there has to be sequential instruction-flow at some level, but it’s abstracted away from you and trying to follow it is counter-productive to understanding how to effectively use the Atomspace.</p>
<div class="section" id="conditional-expressions">
<h2>Conditional Expressions<a class="headerlink" href="#conditional-expressions" title="Permalink to this headline">¶</a></h2>
<p>In the previous chapter, we used a <code class="code docutils literal notranslate"><span class="pre">MeetLink</span></code> and <code class="code docutils literal notranslate"><span class="pre">QueryLink</span></code> to query the “weight_in_kg” of “Fido the Dog”,
and used a different query to find all dogs (actually all atoms) heavier than 10kg.
But how can we cause a different action to be taken, depending on whether or not Fido is heavier than 10kg?</p>
<p>More generally, how do we compose a conditional expression in Atomese?</p>
<p>Let’s start with a simpler conditional.  We’ll use a <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> like this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">CondLink</span>
        <span class="p">(</span><span class="nf">GreaterThan</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>When you execute the Scheme snippet above, you will see <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">ConceptNode</span></span> <span class="s"><span class="pre">“Yes”</span></span><span class="p"><span class="pre">)</span></span></code> because 2 is indeed greater than 1.
Simple enough.  <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> takes either 2 or 3 atoms as arguments.</p>
<p>The first is the <em>conditional</em> predicate atom.  Something that will evaluate to true or false.  There is a lot more to say about this later.
For now, just remember that <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> predicates must be 100% true or they will be considered false.</p>
<p>Argument 2 is the <em>consequent</em> atom, or as I like to think of it, the expression after the <strong>then</strong> keyword in other languages.  Optionally, for argument 3, you can supply a <em>default</em> atom, which is basically the <strong>else</strong> expression, to be executed if the conditional evaluates to false.</p>
<p>Building on that, let’s compare Fido’s weight rather than just comparing some constants.  First we need to bring Fido back into the Atomspace (assuming you’ve cleared things out since last chapter’s exercises).</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">fidos_weight_link</span>
    <span class="p">(</span><span class="nf">ListLink</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Fido the Dog&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;weight_in_kg&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="p">(</span><span class="nf">StateLink</span>
    <span class="nv">fidos_weight_link</span>
    <span class="p">(</span><span class="nf">NumberNode</span> <span class="mf">12.5</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Now we need a predicate that will query for Fido’s weight, and evaluate to true if he’s heavier than 10kg.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">fido_is_big?</span>
    <span class="p">(</span><span class="nf">SatisfactionLink</span>
        <span class="p">(</span><span class="nf">AndLink</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="nv">fidos_weight_link</span>
                <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;dogs_weight_node&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">GreaterThan</span>
                <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;dogs_weight_node&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">10</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Earlier I promised I wouldn’t drop a new atom or other construct on you without at least attempting to demystify it.  <code class="code docutils literal notranslate"><span class="pre">SatisfactionLink</span></code> is yet another query link type.
Fundamentally it’s just like <code class="code docutils literal notranslate"><span class="pre">MeetLink</span></code>, <code class="code docutils literal notranslate"><span class="pre">GetLink</span></code>, <code class="code docutils literal notranslate"><span class="pre">QueryLink</span></code>, and <code class="code docutils literal notranslate"><span class="pre">BindLink</span></code>.</p>
<p>The main feature that sets <code class="code docutils literal notranslate"><span class="pre">SatisfactionLink</span></code> apart is that it evaluates to a TruthValue.  True, aka <code class="code scheme docutils literal notranslate"><span class="nv"><span class="pre">stv</span></span><span class="p"><span class="pre">(</span></span><span class="mi"><span class="pre">1</span></span><span class="o"><span class="pre">,</span></span> <span class="mi"><span class="pre">1</span></span><span class="p"><span class="pre">)</span></span></code>, if the expression could be matched in the Atomspace, and false, aka <code class="code scheme docutils literal notranslate"><span class="nv"><span class="pre">stv</span></span><span class="p"><span class="pre">(</span></span><span class="mi"><span class="pre">0</span></span><span class="o"><span class="pre">,</span></span> <span class="mi"><span class="pre">1</span></span><span class="p"><span class="pre">)</span></span></code>, if not.
There is a lot to say about TruthValues, and we’ll get there soon.  For now you can think of them as Booleans True/False or Yes/No values, just know that there is a lot more to them.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">SatisfactionLink</span></code> is actually the basic building-block from which all of the other query links are constructed.</p>
</div>
<p>Finally, let’s use our new <code class="code scheme docutils literal notranslate"><span class="nv"><span class="pre">fido_is_big?</span></span></code> predicate in a <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> atom.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">CondLink</span>
        <span class="nv">fido_is_big?</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Executing that should get you a resounding <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">ConceptNode</span></span> <span class="s"><span class="pre">“Yes”</span></span><span class="p"><span class="pre">)</span></span></code>!</p>
</div>
<div class="section" id="using-putlink-to-update-the-atomspace">
<h2>Using PutLink to Update the AtomSpace<a class="headerlink" href="#using-putlink-to-update-the-atomspace" title="Permalink to this headline">¶</a></h2>
<p>Now, let’s use the result of our conditional to update some state in the Atomspace.
Recall how, a few chapters ago, we used a <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> to create an exclusive link that can only have one result for a given atom.
Here, we will assign a <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> result depending on a <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code>.</p>
<p>To do this, we will use <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>.  You can think of <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> as the assignment operator of Atomese.
Here in our example, we set the association of <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Predicate</span></span> <span class="s"><span class="pre">“conditional_result”</span></span><span class="p"><span class="pre">)</span></span></code> with one of two possible <code class="code docutils literal notranslate"><span class="pre">ConceptNode</span></code> atoms, using a <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code>.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">PutLink</span>
        <span class="p">(</span><span class="nf">CondLink</span>
            <span class="p">(</span><span class="nf">TrueLink</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;result_placeholder&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;result_placeholder&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>As you probably expected, running the Scheme snippet above produces this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">StateLink</span>
    <span class="p">(</span><span class="nf">PredicateNode</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">ConceptNode</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>So now the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> belonging to <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">PredicateNode</span></span> <span class="s"><span class="pre">“conditional_result”</span></span><span class="p"><span class="pre">)</span></span></code> points to <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">ConceptNode</span></span> <span class="s"><span class="pre">“Yes”</span></span><span class="p"><span class="pre">)</span></span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">TrueLink</span></code> and its mirror-twin <code class="code docutils literal notranslate"><span class="pre">FalseLink</span></code> are atoms that always evaluate to true (or false).  As used above, it’s equivalent to saying “if (true)” in another language, and thus it gives me a concise way to demonstrate the behavior of the <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> atom.</p>
</div>
<p>This <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> expression appears fairly simple but there is a lot going on here, and some of it is subtle and non-obvious.
Understanding <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> is critical to internalizing a key Atomspace concept, i.e. learning how to think about atoms that represent data vs. atoms that represent transformations and operations that can affect the data.</p>
<p>Remember both kinds of atoms live in the Atomspace, and there isn’t a simple rule about whether an atom is “data” or it’s “code”.  Often it can feel like everything is all mixed together.
This is a source of tremendous flexibility, but remember, with great power comes great responsibility ;-)</p>
<p>BORIS, go through why the trivial approach doesn’t work.  i.e. why adding atoms as part of the conditional clobbers the moon</p>
<p>To illustrate this point, what if we were to try this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">PutLink</span>
        <span class="p">(</span><span class="nf">CondLink</span>
            <span class="p">(</span><span class="nf">FalseLink</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;result_placeholder&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;result_placeholder&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">CondLink</span>
        <span class="p">(</span><span class="nf">GreaterThan</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">QuoteLink</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">QuoteLink</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>BORIS, if I explain PutLink here, go on and move some of the earlier dicsussion about PutLink to here.</p>
<p>So we saw above how we could use <code class="code docutils literal notranslate"><span class="pre">cog-evaluate!</span></code> to evaluate a atom to generate a TruthValue.
But how do we utilize that result to control what our program does next?
In other words, what are the Atomese equivalents for program-flow constructs like If-Then statements, Case statements, etc.?</p>
<p>LP: See if I can get the AndLink stuff to work for partial conditionals, testing it with the side-effect-full eval path from the recursive-loop.scm example</p>
<p>In a simple form, like this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-evaluate!</span>
    <span class="p">(</span><span class="nf">GreaterThan</span>
        <span class="p">(</span><span class="nf">Number</span> <span class="mi">10</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Notice that we’ve traded <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code> for <code class="code docutils literal notranslate"><span class="pre">cog-evaluate!</span></code>.
These OpenCog functions are similar, but where <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code> may return anything at all, <code class="code docutils literal notranslate"><span class="pre">cog-evaluate!</span></code> will always return a <em>TruthValue</em>.</p>
</div>
<div class="section" id="the-philosophy-of-truth">
<h2>The Philosophy of Truth<a class="headerlink" href="#the-philosophy-of-truth" title="Permalink to this headline">¶</a></h2>
<p>When you run that <code class="code docutils literal notranslate"><span class="pre">cog-evaluate!</span></code> snippet above, you should get this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">stv</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>“stv” in this case stands for <em>Simple Truth Value</em>, and an STV is composed of two floating point numbers: <em>Strength</em> and <em>Confidence</em>.
In our case, they are both exactly 1.  The expression was 100% true, and we are 100% sure of that.</p>
<p>So, as you can see, this is a step beyond simple bivalent (crisp true or false) logic in both reasoning ability and complexity.</p>
<p>But what precisely does it mean for something to be half-true?  Well… It’s complicated.</p>
<p>Consider the statement “Charlie is tall.”  If Charlie were 210cm tall, most people today would judge that true.
If he were 120cm, most would judge it false.  But what if Charlie were 175cm?  In this case, the statement might be “half-true”.</p>
<p>This line of reasoning was formalized as <a class="reference external" href="https://en.wikipedia.org/wiki/Fuzzy_logic">Fuzzy Logic</a>, by Lotfi Zadeh, whom I was lucky enough to chat with for half an hour, mostly about self-driving cars, back in the year 2000 when I was 19 years old, but I digress…</p>
<p>Using fuzzy logic, we can define a set of all tall people, and then a person with a height of 175cm could have a 50% membership in that set.
In traditional set theory, an object or data point either belongs or doesn’t belong in a set, based on the set membership function.  In other words, traditional sets always have a crisp boundary.  In fuzzy logic, the membership function returns a value between 0 and 1, so there can be a continuous transition from outside the set to inside the set.</p>
<p>But consider the conceptual difference between our statement about Charlie and the statement “The train from Birmingham arrives every day at 10:42am.”  Given the legendary unreliability of the London Midland train service, you’d certainly assign that statement a low truth value.
But this is a probabilistic truth rather than a fuzzy truth.  Some days, the train will indeed arrive on time, but on the majority of days it will not.  This kind of truth value is meant to express a probability that the statement is true.</p>
<p>So in summary, a fuzzy truth value represents the <strong>degree</strong> to which a statement is true, while a probabilistic truth value represents the <strong>chance</strong> that it is true.
Fuzzy truth values are useful for tracking, well fuzzy, statements of known facts, while probabilistic truth values are useful for tracking predictions and known uncertainties.
They are related concepts, but they aren’t mathmatically interchangeable.</p>
<p>Those are two interpretations of the <em>strength</em> component; what about the the <em>confidence</em> component?
Strength represents the known aspect of the truth value and confidence is the unknown aspect.
Consider a truth value of <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">stv</span></span> <span class="mf"><span class="pre">0.5</span></span> <span class="mf"><span class="pre">1.0</span></span><span class="p"><span class="pre">)</span></span></code> for the statement “A coin-flip will land on heads.”  If somebody offered you a bet with better-than-even odds on that coin, you could be confident that your expected return would be positive.
But consider the same statement about an unknown coin <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">stv</span></span> <span class="mf"><span class="pre">0.5</span></span> <span class="mf"><span class="pre">0.0</span></span><span class="p"><span class="pre">)</span></span></code>.  It might be a weighted coin that lands on tails 99% of the time.  From that TruthValue you just don’t know.</p>
<p>OpenCog and the Atomspace support additional types of more complicated TruthValues to cover different situations.
For example there is the <a class="reference external" href="https://wiki.opencog.org/w/FormulaTruthValue">FormulaTruthValue</a> for situations where the truth of an assertion depends on additional factors.  These are good for representing probability distribution functions.
Also there is the <a class="reference external" href="https://wiki.opencog.org/w/TruthValue#CountTruthValue">CountTruthValue</a> for situations where the system continues to collect new observations and refine its assesment of the probability.</p>
<p>Partial truth is a very big topic, and we’re not going to be able to do it justice in this guide.  This section is just a superficial introduction to make you aware of the problem-space.</p>
<p>In general, you can read the official OpenCog reference for TruthValue here: <a class="reference external" href="https://wiki.opencog.org/w/TruthValue">https://wiki.opencog.org/w/TruthValue</a></p>
<p>And now we’ll introduce <em>Probabilistic Logic Networks</em>, or <em>PLNs</em> for short.  PLNs are a way to reason with partial truth values.
OpenCog and PLNs have a shared heritage, and many ideas from PLNs deeply inform the architecture of OpenCog.  We’ll talk a lot more about PLNs in the coming chapters.</p>
<p>For now, you can read an introductory paper on PLNs here: <a class="reference external" href="https://aiatadams.files.wordpress.com/2016/02/invited_paper_3.pdf">https://aiatadams.files.wordpress.com/2016/02/invited_paper_3.pdf</a></p>
<p>And the complete PLN book can be downloaded (for now) here: <a class="reference external" href="https://aiatadams.files.wordpress.com/2016/02/pln_book_6_27_08.pdf">https://aiatadams.files.wordpress.com/2016/02/pln_book_6_27_08.pdf</a></p>
<p>BORIS HERE</p>
<p>Now, we want to put him into a “Big Dog” or a “Small Dog” set, depending on his weight.
But first, we need to define a predicate that will evaluate to true if his weight is above a threshold.</p>
<p>BORIS Unnatural Break</p>
<p>So unlike the other query link types, <code class="code docutils literal notranslate"><span class="pre">SatisfactionLink</span></code> is appropriate to use in an evaluation context rather than in an execution context.  In fact,</p>
<p>Let’s stop here, and just evaluate our new predicate.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-evaluate!</span> <span class="nv">fido_is_big?</span><span class="p">)</span>
</pre></div>
</div>
<p>You should get back <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">stv</span></span> <span class="mi"><span class="pre">0</span></span> <span class="mi"><span class="pre">1</span></span><span class="p"><span class="pre">)</span></span></code>, aka false.  Fido is not heavier than 15kg.  If you’re not convinced, try tweaking Fido’s weight or the predicate to get the answer you want.</p>
<p>BORIS Unnatural Break</p>
<p>Continuing on, we can now create the appropriate <code class="code docutils literal notranslate"><span class="pre">MemberLink</span></code>, depending on how our predicate evaluates.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-evaluate!</span>
    <span class="p">(</span><span class="nf">OrLink</span>
        <span class="p">(</span><span class="nf">AndLink</span>
            <span class="nv">fido_is_big?</span>
            <span class="p">(</span><span class="nf">MemberLink</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Fido the Dog&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;Big Dog&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">MemberLink</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Fido the Dog&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;Small Dog&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>BORIS this is BORKED.  The trouble is that those memberlinks end up existing in the atomspace BECAUSE they exist as part of the query!!!</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-evaluate!</span>
    <span class="p">(</span><span class="nf">OrLink</span>
        <span class="p">(</span><span class="nf">AndLink</span>
            <span class="nv">fido_is_big?</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Fido the Dog&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;Big Dog&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">StateLink</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Fido the Dog&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;Small Dog&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>


<span class="p">(</span><span class="nf">cog-evaluate!</span>
    <span class="p">(</span><span class="nf">MemberLink</span> <span class="p">(</span><span class="nf">stv</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Fido the Dog&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;Small Dog&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>BORIS, talk about how both sides can potentially execute, and it’s just up to the end to decide which side to use.  How there isn’t a program counter, as in precedural programming.</p>
<p>Boris, what happens if something has a truth value of 0.5???  Which link is created???  Both.</p>
<p>BORIS YELTSIN
Talk about side-effect-free vs. side-effects, SequentialAndLink</p>
<p>BORIS introduce StrengthOf &amp; CondfidenceOf</p>
</div>
<div class="section" id="declaring-evaluationlinks">
<h2>Declaring EvaluationLinks<a class="headerlink" href="#declaring-evaluationlinks" title="Permalink to this headline">¶</a></h2>
<p>BORIS, talk about grounding and checking if an assertion is true or not</p>
<p>Assert, (Come up with an example that isn’t an “isa” relationship.  Dogs chew bones, goats chew leaves)</p>
<p>BORIS Below is WRONG!
In the previous chapter, we showed how <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code> could execute certain <em>Active</em> links, resulting in an atom or value being created and returned.
For <em>Declarative</em>, aka passive links, the <code class="code docutils literal notranslate"><span class="pre">cog-evaluate!</span></code> OpenCog function is its counterpart.
Unlike Active Links, Declarative links always evaluate to a <em>TruthValue</em>.</p>
<p>BORIS, include the fact that a truthValue is attached to an atom with a special key.  Explained in values.scm example.</p>
<p>BORIS Let’s ask the Atomspace a true/false question.  “Is Fido an Animal?”</p>
<p>BORIS What to say about EvaluationLink??  We’ve already introduced them above, GreaterThanLink is an EvalLink.</p>
<p>BORIS.  Explain AnchorNodes and VariableLists</p>
<p>BORIS Revisit PredicateNode</p>
<p>BORIS EvaluationLink</p>
<p>BORIS two views, as an assertion with a truth value, or as a way to evaluate the truth of a proposition</p>
<p>BORIS BORIS, How do I query whether something is part of another set</p>
<p>BORIS PredicateFOrmula</p>
<p>BORIS Cover using PutLink to find a location and update it.  For example, search the Atomspace, and put all dogs heavier than 10kg is the “Big Dogs” set.</p>
<p>BORIS VariableList, Typed Variables (CAN I DEFINE MY OWN TYPES???)
BORIS Next Chapter, program segmentation, DefineLinks, Tail Recursion, etc. look at the recursive-loop.scm example.
We’ll also talk about the FFI, like using ExecutionOutput and GroundedSchema, or GroundedPredicate, look at “execute.scm”</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Luke's Atomspace Quickstart Guide</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="01_getting_oriented.html">Getting Oriented &amp; Basic Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_representing_knowledge.html">Structured Knowledge &amp; Simple Queries</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Programming with Atomese</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#conditional-expressions">Conditional Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-putlink-to-update-the-atomspace">Using PutLink to Update the AtomSpace</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-philosophy-of-truth">The Philosophy of Truth</a></li>
<li class="toctree-l2"><a class="reference internal" href="#declaring-evaluationlinks">Declaring EvaluationLinks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="04_logical_inferencing.html">Logical Inferencing</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="02_representing_knowledge.html" title="previous chapter">Structured Knowledge &amp; Simple Queries</a></li>
      <li>Next: <a href="04_logical_inferencing.html" title="next chapter">Logical Inferencing</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Luke Peterson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/contents/03_atomese_programming.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>
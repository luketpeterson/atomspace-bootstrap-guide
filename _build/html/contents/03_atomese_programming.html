
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Programming with Atomese &#8212; Luke&#39;s Atomspace Quickstart Guide 0.0.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Logical Inferencing" href="04_logical_inferencing.html" />
    <link rel="prev" title="Structured Knowledge &amp; Simple Queries" href="02_representing_knowledge.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p id="atomese-programming">Previous Chapter: <a class="reference internal" href="02_representing_knowledge.html#representing-knowledge"><span class="std std-ref">Structured Knowledge</span></a></p>
<div class="section" id="programming-with-atomese">
<h1>Programming with Atomese<a class="headerlink" href="#programming-with-atomese" title="Permalink to this headline">¶</a></h1>
<p>In the previous chapter, we introduced Atomspace queries and a little bit about the execution model with <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code>.
Now we’ll go deeper into some more of the program-flow constructs that allow Atomese to behave like a complete programming language.</p>
<p>In this upcoming chapter, we’ll deal with Atomese approaches to conditionals, code factoring (i.e. functions), and looping.</p>
<p>If you are steeped in procedural programming, like I am, there are things about the Atomspace execution model that will require you to turn your brain inside-out.
On the other hand, if you come from a <a class="reference external" href="https://en.wikipedia.org/wiki/Lambda_calculus">Lambda Calculus</a> or <a class="reference external" href="https://en.wikipedia.org/wiki/Functional_programming">Functional Programming</a> background then, lucky you!
This next parts will be a lot easier to wrap your head around.</p>
<p>The Atomspace is different from procedural programming languages insofar as there isn’t a program counter as I typically understand it.
You can’t “follow” the execution in a sequential fashion the way you might be able to in other languages.
Under the hood, obviously, it’s software running on a microprocessor so there has to be sequential instruction-flow at some level, but it’s abstracted away from you and trying to follow it is counter-productive to understanding how to effectively use the Atomspace.</p>
<div class="section" id="conditional-expressions">
<h2>Conditional Expressions<a class="headerlink" href="#conditional-expressions" title="Permalink to this headline">¶</a></h2>
<p>In the previous chapter, we used a <code class="code docutils literal notranslate"><span class="pre">MeetLink</span></code> and <code class="code docutils literal notranslate"><span class="pre">QueryLink</span></code> to query the “weight_in_kg” of “Fido the Dog”,
and used a different query to find all dogs (actually all atoms) heavier than 10kg.
But how can we cause a different action to be taken, depending on whether or not Fido is heavier than 10kg?</p>
<p>More generally, how do we compose a conditional expression in Atomese?</p>
<p>Let’s start with a simpler conditional.  We’ll use a <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> like this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">CondLink</span>
        <span class="p">(</span><span class="nf">GreaterThan</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>When you execute the Scheme snippet above, you will see <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">ConceptNode</span></span> <span class="s"><span class="pre">“Yes”</span></span><span class="p"><span class="pre">)</span></span></code> because 2 is indeed greater than 1.
Simple enough.  <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> takes either 2 or 3 atoms as arguments.</p>
<p>The first is the <em>conditional</em> predicate atom.  Something that will evaluate to true or false.  There is a lot more to say about this later.
For now, just remember that <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> predicates must be 100% true or they will be considered false.</p>
<p>Argument 2 is the <em>consequent</em> atom, or as I like to think of it, the expression after the <strong>then</strong> keyword in other languages.  Optionally, for argument 3, you can supply a <em>default</em> atom, which is basically the <strong>else</strong> expression, to be executed if the conditional evaluates to false.</p>
<p>Building on that, let’s compare Fido’s weight rather than just comparing some constants.  First we need to bring Fido back into the Atomspace (assuming you’ve cleared things out since last chapter’s exercises).</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">fidos_weight_link</span>
    <span class="p">(</span><span class="nf">ListLink</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Fido the Dog&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;weight_in_kg&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="p">(</span><span class="nf">StateLink</span>
    <span class="nv">fidos_weight_link</span>
    <span class="p">(</span><span class="nf">NumberNode</span> <span class="mf">12.5</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Now we need a predicate that will query for Fido’s weight, and evaluate to true if he’s heavier than 10kg.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">fido_is_big?</span>
    <span class="p">(</span><span class="nf">SatisfactionLink</span>
        <span class="p">(</span><span class="nf">AndLink</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="nv">fidos_weight_link</span>
                <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;dogs_weight_node&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">GreaterThan</span>
                <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;dogs_weight_node&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">10</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Earlier I promised I wouldn’t drop a new atom or other construct on you without at least attempting to demystify it.  <code class="code docutils literal notranslate"><span class="pre">SatisfactionLink</span></code> is yet another query link type.
Fundamentally it’s just like <code class="code docutils literal notranslate"><span class="pre">MeetLink</span></code>, <code class="code docutils literal notranslate"><span class="pre">GetLink</span></code>, <code class="code docutils literal notranslate"><span class="pre">QueryLink</span></code>, and <code class="code docutils literal notranslate"><span class="pre">BindLink</span></code>.</p>
<p>The main feature that sets <code class="code docutils literal notranslate"><span class="pre">SatisfactionLink</span></code> apart is that it evaluates to a TruthValue.  True, aka <code class="code scheme docutils literal notranslate"><span class="nv"><span class="pre">stv</span></span><span class="p"><span class="pre">(</span></span><span class="mi"><span class="pre">1</span></span><span class="o"><span class="pre">,</span></span> <span class="mi"><span class="pre">1</span></span><span class="p"><span class="pre">)</span></span></code>, if the expression could be matched in the Atomspace, and false, aka <code class="code scheme docutils literal notranslate"><span class="nv"><span class="pre">stv</span></span><span class="p"><span class="pre">(</span></span><span class="mi"><span class="pre">0</span></span><span class="o"><span class="pre">,</span></span> <span class="mi"><span class="pre">1</span></span><span class="p"><span class="pre">)</span></span></code>, if not.
There is a lot to say about TruthValues, and we’ll get there soon.  For now you can think of them as Boolean True/False or Yes/No values, just know that there is a lot more to them.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">SatisfactionLink</span></code> is actually the basic building-block from which all of the other query link types are constructed.</p>
</div>
<p>Finally, let’s use our new <code class="code scheme docutils literal notranslate"><span class="nv"><span class="pre">fido_is_big?</span></span></code> predicate in a <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> atom.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">CondLink</span>
        <span class="nv">fido_is_big?</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Executing that should get you a resounding <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">ConceptNode</span></span> <span class="s"><span class="pre">“Yes”</span></span><span class="p"><span class="pre">)</span></span></code>!</p>
</div>
<div class="section" id="using-putlink-to-modify-the-atomspace">
<h2>Using PutLink to Modify the AtomSpace<a class="headerlink" href="#using-putlink-to-modify-the-atomspace" title="Permalink to this headline">¶</a></h2>
<p>Now, let’s use the result of our conditional to update some state in the Atomspace.
Recall how, a few chapters ago, we used a <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> to create an exclusive link that can only have one result for a given atom.
Here, we will assign a <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> result depending on a <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> conditional execution.</p>
<p>To do this, we will use <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>.  You can think of <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> as the assignment operator of Atomese, akin to “<strong>=</strong>” or “<strong>:=</strong>” in other languages.
Here in our example, we set the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> association of <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Predicate</span></span> <span class="s"><span class="pre">“conditional_result”</span></span><span class="p"><span class="pre">)</span></span></code> with one of two possible <code class="code docutils literal notranslate"><span class="pre">ConceptNode</span></code> atoms.</p>
<p>In reality, the comparison of <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> to the assignment operator is flawed because of enormous fundamental differences between the Atomspace and the traditional precedural programming language execution model.
The <a class="reference external" href="https://wiki.opencog.org/w/PutLink">OpenCog PutLink documentation</a> more accurately describes <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> as a <em>Beta Redex</em>, but without a Lambda Calculus background that didn’t connect for me.
So, I found the analogy to assignment to be a useful way of bootstrapping my understanding, not only of <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> itself, but the process of learning about <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> gave me a deeper understanding of the Atomspace as a whole.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">PutLink</span>
        <span class="p">(</span><span class="nf">CondLink</span>
            <span class="p">(</span><span class="nf">TrueLink</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;result_placeholder&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;result_placeholder&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>As you probably expected, running the Scheme snippet above produces this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">StateLink</span>
    <span class="p">(</span><span class="nf">PredicateNode</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">ConceptNode</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>So now the one and only <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> associated with <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">PredicateNode</span></span> <span class="s"><span class="pre">“conditional_result”</span></span><span class="p"><span class="pre">)</span></span></code> points to <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">ConceptNode</span></span> <span class="s"><span class="pre">“Yes”</span></span><span class="p"><span class="pre">)</span></span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">TrueLink</span></code> and its mirror-twin <code class="code docutils literal notranslate"><span class="pre">FalseLink</span></code> are atoms that always evaluate to true (or false).  As used above, it’s equivalent to saying “if (true)” in another language, and thus it gives me a concise way to demonstrate the behavior of the <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> atom.</p>
</div>
<p>This <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> expression appears fairly simple but some of the behavior is a bit subtle and non-obvious, and it tripped me up badly at first.
Understanding <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> is critical to internalizing a key Atomspace concept, i.e. learning how to think about atoms that represent data aka program state vs. atoms that represent operations that can affect the data.
In another programming language we would call these “data” and “code”.</p>
<p>Remember both kinds of atoms live in the Atomspace, and there isn’t a simple rule about whether an atom is “data” or it’s “code”.  Often it can feel like everything is all mixed together.
This is a source of tremendous flexibility, but remember, with great power comes great responsibility ;-)</p>
<p>So back to <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>.  Like the name suggests, it “Puts” atoms into the Atomspace.
The simplest valid <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> I could compose looks like this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">PutLink</span>
        <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;atom_placeholder&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;The Atom We Are Putting In&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>But hold on…  What’s the point?  Isn’t that identical to just: <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Concept</span></span> <span class="s"><span class="pre">“The</span> <span class="pre">Atom</span> <span class="pre">We</span> <span class="pre">Are</span> <span class="pre">Putting</span> <span class="pre">In”</span></span><span class="p"><span class="pre">)</span></span></code>?</p>
<p>Yes.  Yes it is.  <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> is not the only way to put atoms into the Atomspace.
We’ve been putting atoms in the Atomspace since the very first example in this guide.
So why do we need <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> then?</p>
<div class="section" id="ungrounded-expressions-can-represent-latent-code">
<h3>Ungrounded Expressions can Represent “Latent Code”<a class="headerlink" href="#ungrounded-expressions-can-represent-latent-code" title="Permalink to this headline">¶</a></h3>
<p>Let’s look at what’s wrong with this naïve attempt to set our result <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> from the first example.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">CondLink</span>
        <span class="p">(</span><span class="nf">TrueLink</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">StateLink</span>
            <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Yes&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">StateLink</span>
            <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Try it!  Did it do what you expected?  I know I was puzzled when I encountered this behavior.  Actually “annoyed” and “frustrated” are more accurate words.</p>
<p>A clue to what is happening can be found by dropping the <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code>, and just observing what happens when the <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code> and all its referenced atoms are added to the Atomspace.
Notice that the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> connecting <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Predicate</span></span> <span class="s"><span class="pre">“conditional_result”</span></span><span class="p"><span class="pre">)</span></span></code> to <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Concept</span></span> <span class="s"><span class="pre">“Yes”</span></span><span class="p"><span class="pre">)</span></span></code> is gone altogether.
Remember that the act of creating a <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> removes a prior extant <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> with the same target.</p>
<p>This left me scratching my head for a minute.  I was stuck in the mindset that I was just inputting code, and the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> behavior would only be triggered when the code actually executed.  Wrong!</p>
<p>As I inputted the first arm of the <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code>, I actually assigned the result to “Yes” by creating the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code>.
Then, when I inputted the second arm, I re-assigned the result to “No”, by creating the new <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code>, thus triggering the old one to be destroyed.</p>
<p>Finally, when I executed the <code class="code docutils literal notranslate"><span class="pre">CondLink</span></code>, there was no “else” clause atom, because the “then” clause atom had disappeared and so the former “else” clause atom became argument 2, and was interpreted as the “then” clause atom.
So the atom I actually executed looked like this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">CondLink</span>
    <span class="p">(</span><span class="nf">TrueLink</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">StateLink</span>
        <span class="p">(</span><span class="nf">PredicateNode</span> <span class="s">&quot;conditional_result&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">ConceptNode</span> <span class="s">&quot;No&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Basically <code class="code docutils literal notranslate"><span class="pre">if</span> <span class="pre">(true)</span> <span class="pre">{</span> <span class="pre">result</span> <span class="pre">=</span> <span class="pre">No;</span> <span class="pre">}</span></code>.  Oops.</p>
<p>So what’s the solution?</p>
<p>We introduced ungrounded vs. grounded expressions last chapter when discussing queries.
I remember saying (typing) “Think of a grounded expression as a statement and an ungrounded expression as a question.”</p>
<p>Now I’ll add a bit more nuance.  You can also think of an ungrounded expression as a <strong>Hypothetical</strong> or <strong>Abstract</strong> statement.
As long as an expression is ungrounded, it doesn’t really say anything specific or concrete.</p>
<p>So in terms of the example, the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> atoms we want to input say “Connect <em>something</em> with ‘Yes’” and “Connect <em>something</em> with ‘No’”.
But without that <em>something</em> being a specific concrete atom, the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> can’t do its behavior to ensure uniqueness and thus both <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> atoms are allowed to exist at the same time.</p>
<p>That’s where <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> comes in.  When <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> is executed, the ungrounded expression is grounded using the atom(s) supplied to <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>.
In the case of the example, that is <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Predicate</span></span> <span class="s"><span class="pre">“conditional_result”</span></span><span class="p"><span class="pre">)</span></span></code> .  And the atoms of the newly grounded expression are put into the Atomspace.</p>
</div>
<div class="section" id="grounding-a-deletelink-removes-an-atom">
<h3>Grounding a DeleteLink Removes an Atom<a class="headerlink" href="#grounding-a-deletelink-removes-an-atom" title="Permalink to this headline">¶</a></h3>
<p>We just saw how grounding a <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> can cause another conflicting <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> atom to be deleted if they share the same target atom.
This is a special case of a general behavior.  To illustrate that, I’ll introduce the <code class="code docutils literal notranslate"><span class="pre">DeleteLink</span></code> atom.</p>
<p>As long as the <code class="code docutils literal notranslate"><span class="pre">DeleteLink</span></code> remains ungrounded, it doesn’t to anything.
But the instant it is grounded, it ceases to exist, and takes whatever atoms it references out along with it.</p>
<p>Consider this Scheme snippet:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">hello</span> <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Here I am!&quot;</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">delete_me</span>
    <span class="p">(</span><span class="nf">PutLink</span>
        <span class="p">(</span><span class="nf">DeleteLink</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;the_concept&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="nv">hello</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>We just defined two scheme symbols: <code class="code docutils literal notranslate"><span class="pre">hello</span></code> and <code class="code docutils literal notranslate"><span class="pre">delete_me</span></code>.  Let’s prove <code class="code docutils literal notranslate"><span class="pre">hello</span></code> exists by having a look.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">display </span><span class="nv">hello</span><span class="p">)</span>
</pre></div>
</div>
<p>Yup.  Just where we left it.
We can also look at <code class="code docutils literal notranslate"><span class="pre">delete_me</span></code>, and we will see it contains an ungrounded <code class="code docutils literal notranslate"><span class="pre">DeleteLink</span></code> expression.</p>
<p>But what happens when we execute <code class="code docutils literal notranslate"><span class="pre">delete_me</span></code>?</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span> <span class="nv">delete_me</span><span class="p">)</span>
</pre></div>
</div>
<p>Well… We just annihilated the atom referenced by <code class="code docutils literal notranslate"><span class="pre">hello</span></code>.  To prove it, we’ll try to display it again.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">display </span><span class="nv">hello</span><span class="p">)</span>
</pre></div>
</div>
<p>So sad. :-(  We now get <code class="code docutils literal notranslate"><span class="pre">#&lt;Invalid</span> <span class="pre">handle&gt;</span></code>.</p>
<p>Of course, deleting a pre-specified atom using a <code class="code docutils literal notranslate"><span class="pre">DeleteLink</span></code> inside a <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> isn’t really any more useful than just declaring the <code class="code docutils literal notranslate"><span class="pre">DeleteLink</span></code> directly, and skipping all the <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> machinations.
We could have just done this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span> <span class="p">(</span><span class="nf">DeleteLink</span> <span class="nv">hello</span><span class="p">))</span>
</pre></div>
</div>
<p>However, next, we’ll cover how to query for atoms inside a <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>, so we’ll be able to do things like deleting all atoms returned by a query, for example.</p>
<p>At some point, I recommend exploring the Atomspace execution model further by going through the <a class="reference external" href="https://github.com/opencog/atomspace/blob/master/examples/atomspace/assert-retract.scm">“assert-retract.scm” OpenCog example</a>.
In particular, understanding the mechanics of <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> and <code class="code docutils literal notranslate"><span class="pre">DeleteLink</span></code> will help you understand what really happens when you invoke <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code>.</p>
</div>
<div class="section" id="finding-atoms-with-a-query-inside-a-putlink">
<h3>Finding Atoms with a Query Inside a PutLink<a class="headerlink" href="#finding-atoms-with-a-query-inside-a-putlink" title="Permalink to this headline">¶</a></h3>
<p>To implement any complex behavior beyond the trivial toy examples we’ve seen so far,
like our conditional above that branched based on a constant, we need to operate on data from the Atomspace.</p>
<p>Consider a simple counter that might be written in C like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>How would that look in Atomese?</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">State</span> <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Number</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">PutLink</span>
        <span class="p">(</span><span class="nf">State</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">PlusLink</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_num&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">MeetLink</span>
            <span class="p">(</span><span class="nf">State</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_num&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>As you can see in both C and Atomese, we begin by declaring <code class="code docutils literal notranslate"><span class="pre">counter</span></code> and initially setting it to 0 (Zero).
In a way, a declaration with an initial value is like an assignment, but you couldn’t write much of a program using only declarations in C, and that’s also true in Atomese.</p>
<p>So, looking at the interesting part of the example, we supplied two atoms to <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>.
We can think of the first argument as being like the “R-Value” and the second argument as being like the “L-Value”.
That’ll mean something if you’ve spent significant time working through gcc errors.
If not, consider yourself fortunate for avoiding that particular drain of life energy.</p>
<p>Basically, the first argument is the expression to the right of the equal-sign in the assignment.
From our C example, that would be <code class="code c docutils literal notranslate"><span class="n"><span class="pre">counter</span></span> <span class="o"><span class="pre">+</span></span> <span class="mi"><span class="pre">1</span></span></code>.  Think of the R-Value as “what” is being assigned.</p>
<p>The second argument to <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> is the part of the assignment to the left of the equal side.
From our C example, that would be <code class="code c docutils literal notranslate"><span class="n"><span class="pre">counter</span></span></code>.  Think of the L-Value as “where” you are assigning to.</p>
<p>Again, this is a flawed comparison with the assignment operation in C, so don’t try and stretch the analogy too far.
For example, you could change the ConceptNode in the first expression, so a totally different atom would be created by executing the <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>
Therefore, it’s more accurate to say the second argument matches existing atoms, providing concrete meanings to the <code class="code docutils literal notranslate"><span class="pre">VariableNode</span></code> atoms in the first argument,
While the first argument is a template for the new atoms to insert into the Atomspace, after that template is grounded in terms of the second argument.</p>
<p>Coming full circle, <code class="code docutils literal notranslate"><span class="pre">QueryLink</span></code> and <code class="code docutils literal notranslate"><span class="pre">BindLink</span></code> are actually implemented using PutLink.
The increment example above is functionally equivalent to this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">QueryLink</span>
        <span class="p">(</span><span class="nf">State</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_num&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">State</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">PlusLink</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;our_num&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference external" href="https://github.com/opencog/atomspace/blob/master/examples/atomspace/get-put.scm">“get-put.scm” OpenCog example</a>
Further explores <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> and demonstrates exactly how a <code class="code docutils literal notranslate"><span class="pre">BindLink</span></code> can be composed from a <code class="code docutils literal notranslate"><span class="pre">GetLink</span></code> and a <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code>.
I recommend going through that example as well as the <a class="reference external" href="https://github.com/opencog/atomspace/blob/master/examples/atomspace/bindlink.scm">“bindlink.scm” example</a>.</p>
</div>
</div>
<div class="section" id="defines-schemas-lambdas-and-functions-in-atomese">
<h2>Defines, Schemas, Lambdas and Functions in Atomese<a class="headerlink" href="#defines-schemas-lambdas-and-functions-in-atomese" title="Permalink to this headline">¶</a></h2>
<p>Up until now, we’ve been using Scheme’s <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">define</span></span><span class="p"><span class="pre">)</span></span></code> mechanism to as a way to get a symbolic reference to an atom we intend to use later.
But this mechanism has some limitations that we’re about to cover, not to mention its reliance on Scheme.
Remember the Atomspace can theoretically be accessed from other non-Scheme environments.</p>
<p>In this section we’re going to introduce some code segmentation and organization primitives that are native to Atomese.</p>
<p>Let’s being with Atomese’s own version of <code class="code docutils literal notranslate"><span class="pre">define</span></code>, the <code class="code docutils literal notranslate"><span class="pre">DefineLink</span></code>.  Here’s an example:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">Define</span> <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;five&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">NumberNode</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
<p>We just introduced two new atom types: <code class="code docutils literal notranslate"><span class="pre">DefineLink</span></code> and <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code>.  <code class="code docutils literal notranslate"><span class="pre">DefineLink</span></code> gives a name to something else.  That’s it.</p>
<p>The first argument to a <code class="code docutils literal notranslate"><span class="pre">DefineLink</span></code> needs to be a “naming” node.
There are 3 special “naming” node types: <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code>, <code class="code docutils literal notranslate"><span class="pre">DefinedPredicateNode</span></code>, and <code class="code docutils literal notranslate"><span class="pre">DefinedTypeNode</span></code>.
We’ll cover the latter two in due course, but here we’ll focus on <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code>.
The second atom provided to <code class="code docutils literal notranslate"><span class="pre">DefineLink</span></code> is the definition body.  In our case, it is just a simple <code class="code docutils literal notranslate"><span class="pre">NumberNode</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code> is the most general of the “naming” node types.  A <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code> can give a name to any other atom.</p>
<p>We can now use our <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code> as we would use the atom it represents…  Almost.
This example below does exactly what you think it should do.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">State</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;counter&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;five&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>But without the <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code>, the <code class="code docutils literal notranslate"><span class="pre">StateLink</span></code> connects <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">Concept</span></span> <span class="s"><span class="pre">“counter”</span></span><span class="p"><span class="pre">)</span></span></code> to <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">DefinedSchemaNode</span></span> <span class="s"><span class="pre">“five”</span></span><span class="p"><span class="pre">)</span></span></code>, and not to <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">NumberNode</span></span> <span class="mi"><span class="pre">5</span></span><span class="p"><span class="pre">)</span></span></code>.
The <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code> will be replaced by the node it represents, but only when it is reduced by executing it.
Think of it like a <code class="code c docutils literal notranslate"><span class="k"><span class="pre">const</span></span></code> in C, not like a pre-processor <code class="code c docutils literal notranslate"><span class="cp"><span class="pre">#define</span></span></code>.</p>
<div class="section" id="basic-subroutines">
<h3>Basic Subroutines<a class="headerlink" href="#basic-subroutines" title="Permalink to this headline">¶</a></h3>
<p><code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code> can also be used to define subroutines.  By subroutine I mean a block of code you can call, but where there are no function arguments.
The expectation is that all communication between the subroutine and the caller happens by way of global program state.
Subroutines are just a way to dispatch one chunk of code from a different place in the program.
Most modern programming languages don’t even have subroutines because they can lead to hideous spaghetti code and functions with arguments reduce to subroutines in the case where no arguments are needed.
If you’ve written assembly code by hand or worked with a very old language like <a class="reference external" href="https://en.wikipedia.org/wiki/Integer_BASIC">Integer BASIC</a>, you’ll certainly appreciate why subroutines are insufficient to architect a complex piece of software.</p>
<p>All that said, subroutines are simpler than functions so let’s start there.
Here is an example:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchemaNode</span> <span class="s">&quot;turn_on_switch&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">PutLink</span>
        <span class="p">(</span><span class="nf">State</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;switch_placeholder&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;On&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Global Switch&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>We can call it like this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span> <span class="p">(</span><span class="nf">DefinedSchemaNode</span> <span class="s">&quot;turn_on_switch&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>That’s it.  The <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">DefinedSchemaNode</span></span> <span class="s"><span class="pre">“turn_on_switch”</span></span><span class="p"><span class="pre">)</span></span></code> takes the place of the whole <code class="code docutils literal notranslate"><span class="pre">PutLink</span></code> and all its dependent atoms.</p>
</div>
<div class="section" id="lambdalink-lets-you-pass-function-arguments">
<h3>LambdaLink Lets you Pass Function Arguments<a class="headerlink" href="#lambdalink-lets-you-pass-function-arguments" title="Permalink to this headline">¶</a></h3>
<p>The difference between subroutines vs. procedures and functions are the arguments that can be passed.
<code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code> is the mechanism for defining functions in Atomese, and specifying the arguments that can be passed in.</p>
<p>Here is an example function that squares the incoming <code class="code docutils literal notranslate"><span class="pre">NumberNode</span></code> argument:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchemaNode</span> <span class="s">&quot;square&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">LambdaLink</span>
        <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">TimesLink</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>So there’s our function.  It takes a <code class="code docutils literal notranslate"><span class="pre">NumberNode</span></code> and squares it.
The first argument to <code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code> is <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">VariableNode</span></span> <span class="s"><span class="pre">“x”</span></span><span class="p"><span class="pre">)</span></span></code>.  This specifies that our function expects one argument, and we’re mapping that argument onto <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">VariableNode</span></span> <span class="s"><span class="pre">“x”</span></span><span class="p"><span class="pre">)</span></span></code>.</p>
<p>Now, how do we call it?</p>
<p>Well, unfortunately we can’t just <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code> it like the simple subroutine.  That will cause an error.
The reason is a little bit convoluted, but in essence, we need a seperate operation to pack up the arguments and bind them to the <code class="code docutils literal notranslate"><span class="pre">VariableNode</span></code> atoms used inside the fucntion, and then dispatch the function execution.
That “dispatch” process is handled by the <code class="code docutils literal notranslate"><span class="pre">ExecutionOutputLink</span></code> atom.
Atomese is very “assembly-language-like”, so very little is magically done for you, as might happen in higher-level languages.</p>
<p>We call it like this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">ExecutionOutputLink</span>
        <span class="p">(</span><span class="nf">DefinedSchemaNode</span> <span class="s">&quot;square&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">NumberNode</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The first argument is our <code class="code docutils literal notranslate"><span class="pre">DefinedSchemaNode</span></code>, and the second atom argument is the parameter we are passing to our function.</p>
</div>
<div class="section" id="typed-variables-and-variablelists-as-arguments">
<h3>Typed Variables and VariableLists as Arguments<a class="headerlink" href="#typed-variables-and-variablelists-as-arguments" title="Permalink to this headline">¶</a></h3>
<p><code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code> takes a single atom to specify its argument, but what if we want to pass multiple arguments to a function?
Enter the <code class="code docutils literal notranslate"><span class="pre">VariableList</span></code> atom.  A <code class="code docutils literal notranslate"><span class="pre">VariableList</span></code>, as the name would suggest, is an ordered list to define multiple <code class="code docutils literal notranslate"><span class="pre">VariableNode</span></code> atoms.</p>
<p>You can use it with a <code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code>, as in the example below, where I’ve reimplemented simple multiplication using <code class="code docutils literal notranslate"><span class="pre">TimesLink</span></code>.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;multiply&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">LambdaLink</span>
        <span class="p">(</span><span class="nf">VariableList</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;y&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">TimesLink</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;y&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>And we use a <code class="code docutils literal notranslate"><span class="pre">ListLink</span></code> to pass the arguments, when we want to call it.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">ExecutionOutputLink</span>
        <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;multiply&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">List</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Number</span> <span class="mi">3</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>If your list doesn’t have enough arguments to match the <code class="code docutils literal notranslate"><span class="pre">VariableList</span></code> of the <code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code> that you are calling, then it will cause an error.
On the other hand, if you pass additional extraneous arguments they will be silently ignored.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">VariableList</span></code> is one type of <code class="code docutils literal notranslate"><span class="pre">Connector</span></code>.  <code class="code docutils literal notranslate"><span class="pre">Connector</span></code> atoms are used to declare which atoms may be linked with which other atoms.  They are key to specifying custom grammars, which we will cover later on.</p>
</div>
<p>We have been using “naked” <code class="code docutils literal notranslate"><span class="pre">VariableNode</span></code> atoms, which can map onto any other atom whatsoever, irrespective of the atom’s type.
In some situations we may want to constrain the types of atoms that our function accept as arguments.
This is done with a <code class="code docutils literal notranslate"><span class="pre">TypedVariableLink</span></code>.</p>
<p>Here is the “multiply” function from above, but using <code class="code docutils literal notranslate"><span class="pre">TypedVariableLink</span></code> atoms to declare that the parameters should be <code class="code docutils literal notranslate"><span class="pre">NumberNode</span></code> atoms.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchema</span> <span class="s">&quot;multiply&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">LambdaLink</span>
        <span class="p">(</span><span class="nf">VariableList</span>
            <span class="p">(</span><span class="nf">TypedVariableLink</span>
                <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">TypeNode</span> <span class="s">&quot;NumberNode&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">TypedVariableLink</span>
                <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;y&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">TypeNode</span> <span class="s">&quot;NumberNode&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">TimesLink</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;y&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">TypeNode</span></code> is an atom type that represents an atom type.  Whoa… that’s meta.
It can refer to any of the built-in atom types we’ve used so far; in addition, new types can be defined.
In a later chapter we’ll get deeper into Signatures and creating new atom types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>QUESTION FOR SOMEBODY SMARTER THAN ME.  What is <code class="code docutils literal notranslate"><span class="pre">TypedVariableLink</span></code> actually useful for when used in a <code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code>?  It seems to be ignored when executing lambdas.  I see how it gives extra criteria when matching.  Am I missing something?</p>
</div>
<p>Finally, I should mention that the variable declaration features of Atomese aren’t just for <code class="code docutils literal notranslate"><span class="pre">LambdaLink</span></code> and functions.</p>
<p><code class="code docutils literal notranslate"><span class="pre">VariableList</span></code> and <code class="code docutils literal notranslate"><span class="pre">TypedVariableLink</span></code> can be used with any of the query link types, such as <code class="code docutils literal notranslate"><span class="pre">MeetLink</span></code>, <code class="code docutils literal notranslate"><span class="pre">QueryLink</span></code>, <code class="code docutils literal notranslate"><span class="pre">SatisfactionLink</span></code>, etc.
Often including a <code class="code docutils literal notranslate"><span class="pre">VariableList</span></code> in a match expression is optional, because the variables can be inferred from the expression itself.
When there is any ambiguity, however, including a <code class="code docutils literal notranslate"><span class="pre">VariableList</span></code> is required.</p>
<p>In addition, including a <code class="code docutils literal notranslate"><span class="pre">TypedVariableLink</span></code> can help narrow down the possible matches that can satisfy a query.</p>
</div>
</div>
<div class="section" id="looping-with-tail-recursion">
<h2>Looping with Tail Recursion<a class="headerlink" href="#looping-with-tail-recursion" title="Permalink to this headline">¶</a></h2>
<p>BORIS  Implement a simple counter that increments a number 5 times using a DefinedSchemaLink</p>
<p>BORISYELTSIN, here’s where the new chapter starts…</p>
<p>BORIS, Section below should be part of the lead-in to using SequentialAndLink and SequentialOrLink</p>
<p>You may have already stumbled into this, but you can use a <code class="code docutils literal notranslate"><span class="pre">ListLink</span></code> to execute multiple operations.
Here’s an example:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">DefineLink</span>
    <span class="p">(</span><span class="nf">DefinedSchemaNode</span> <span class="s">&quot;make_nighttime&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">ListLink</span>
        <span class="p">(</span><span class="nf">PutLink</span>
            <span class="p">(</span><span class="nf">State</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;switch_placeholder&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;On&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Moonlight&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">PutLink</span>
            <span class="p">(</span><span class="nf">State</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;switch_placeholder&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Off&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Sunlight&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="section" id="local-variables">
<h3>Local Variables<a class="headerlink" href="#local-variables" title="Permalink to this headline">¶</a></h3>
<p>BORIS, I can’t actually figure out how to use local variables in Lambdas, but I’m also not convinced they are needed.</p>
<p>Distilling the benefits of functions down to just argument passing really doesn’t do justice to the concept.
Functions provide a means manage the side-effects that a subroutine can produce.
In other words, if a function produces</p>
<p>BORIS.  Create a return value from a function.
Then create an increment function where the value passes through a local variable, think up a way that the function would cross-talk with itself from one calling to the next.
BORIS BEST IDEA, Make a recursive function that have 2-dimensions so it interferes with itself.
Consider implementing a “list_of_n_primes” function.  That might be the best way to contrive a variable confict, and if not it’ll still be good practice.
Read the parallelism OpenCog Example.</p>
<p>BORIS CHAPTER FLOW IDEAS.
In the next chapter, introduce EvaluationLink and DefinedPredicate.
Then go on to cover the use of SequentialAnd, SequentialOr, and other constructs to compose programs.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-evaluate!</span>
<span class="p">(</span><span class="nf">Evaluation</span>
    <span class="p">(</span><span class="nf">DefinedPredicate</span> <span class="s">&quot;is_pos_integer?&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>


<span class="p">(</span><span class="nf">Define</span>
    <span class="p">(</span><span class="nf">DefinedPredicateNode</span> <span class="s">&quot;is_pos_integer?&quot;</span><span class="p">)</span>
    <span class="c1">; Determines whether &quot;x&quot; is a positive integer, i.e. ?(x &gt; 0 &amp;&amp; x % 1 == 0)</span>
    <span class="c1">; The lack of a native % (mod) fn turns a constant-time op into an order n op. :-(</span>
    <span class="c1">; Also not numerically stable for high values of x, due to floating point rounding</span>

    <span class="p">(</span><span class="nf">Lambda</span>
        <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">SequentialAndLink</span>

            <span class="c1">; As long as x is greater-than-or-equal-to 1, we can continue</span>
            <span class="c1">; Otherwise we will return false</span>
            <span class="p">(</span><span class="nf">NotLink</span> <span class="p">(</span><span class="nf">GreaterThanLink</span> <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

            <span class="p">(</span><span class="nf">SequentialOrLink</span>

                <span class="c1">; See if our number is exactly 1, return true if so</span>
                <span class="p">(</span><span class="nf">EqualLink</span> <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">))</span>

                <span class="c1">; Recurse with 1 minus our number</span>
                <span class="p">(</span><span class="nf">Evaluation</span>
                    <span class="p">(</span><span class="nf">DefinedPredicateNode</span> <span class="s">&quot;is_pos_integer?&quot;</span><span class="p">)</span>
                    <span class="p">(</span><span class="nf">MinusLink</span>
                        <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
                        <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>


<span class="nv">BORIS,</span> <span class="nv">looks</span> <span class="nv">like</span> <span class="nv">I</span> <span class="nv">will</span> <span class="nv">need</span> <span class="nv">to</span> <span class="nv">explain</span> <span class="nv">DefinedPredicate,</span> <span class="nv">which</span> <span class="nv">means</span> <span class="nv">I</span><span class="ss">&#39;ll</span> <span class="nv">probably</span> <span class="nv">need</span> <span class="nv">to</span> <span class="nv">explain</span> <span class="nv">evaluation</span>
<span class="nv">BORIS,</span> <span class="nv">write</span> <span class="nv">up</span> <span class="nv">SequentialAnd</span> <span class="nv">&amp;</span> <span class="nv">SequentialOr,</span> <span class="k">and </span><span class="nv">how</span> <span class="nv">they</span> <span class="nv">fit</span> <span class="nv">in,</span>
    <span class="nv">This</span> <span class="nv">will</span> <span class="nv">require</span> <span class="nv">drawing</span> <span class="nv">a</span> <span class="nv">diagram</span> <span class="nv">of</span> <span class="nv">AND,</span> <span class="nv">OR,</span> <span class="k">and </span><span class="nv">NOT</span> <span class="nv">gates</span><span class="o">.</span>
<span class="nv">BORIS,</span> <span class="nv">look</span> <span class="nv">at</span> <span class="nv">PredicateFormula,</span> <span class="nv">it</span> <span class="nv">Constructs</span> <span class="nv">a</span> <span class="nv">TruthValue</span> <span class="nv">from</span> <span class="nv">two</span> <span class="nv">number</span> <span class="nv">values</span>
</pre></div>
</div>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">Define</span>
    <span class="p">(</span><span class="nf">DefinedPredicateNode</span> <span class="s">&quot;is_prime_helper&quot;</span><span class="p">)</span>
    <span class="c1">; Determines whether &quot;x&quot; is evenly divisible by &quot;i&quot; or another integer greater than &quot;i&quot;</span>
    <span class="c1">; In otherwords, returns partial NOT prime.  Intended to be called by &quot;is_prime?&quot;</span>
    <span class="c1">; If called with i=2, false = x is prime, true = x is not prime</span>

    <span class="p">(</span><span class="nf">Lambda</span>
        <span class="p">(</span><span class="nf">VariableList</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;i&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">SequentialAndLink</span>

            <span class="c1">; If i is greater-than-or-equal-to x, return false because we&#39;ve tried all possibilities, so it must be prime</span>
            <span class="c1">; Ideally we could stop at sqrt(x), but if I cared about efficiency, I&#39;d implement native modulo first</span>
            <span class="p">(</span><span class="nf">GreaterThan</span> <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;i&quot;</span><span class="p">)</span> <span class="p">)</span> <span class="c1">; greater-than-or-equal is the same as not-less-than</span>

            <span class="p">(</span><span class="nf">SequentialOrLink</span>
                <span class="c1">; Check to see if x is evenly divisible by i, if so, return true</span>
                <span class="p">(</span><span class="nf">Evaluation</span>
                    <span class="p">(</span><span class="nf">DefinedPredicateNode</span> <span class="s">&quot;is_pos_integer?&quot;</span><span class="p">)</span>
                    <span class="p">(</span><span class="nf">DivideLink</span> <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;i&quot;</span><span class="p">))</span>
                <span class="p">)</span>

                <span class="c1">; Recurse with i++</span>
                <span class="p">(</span><span class="nf">Evaluation</span>
                    <span class="p">(</span><span class="nf">DefinedPredicateNode</span> <span class="s">&quot;is_prime_helper&quot;</span><span class="p">)</span>
                    <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
                    <span class="p">(</span><span class="nf">PlusLink</span> <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;i&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Number</span> <span class="mi">1</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="p">(</span><span class="nf">cog-evaluate!</span>
<span class="p">(</span><span class="nf">Evaluation</span>
    <span class="p">(</span><span class="nf">DefinedPredicate</span> <span class="s">&quot;is_prime_helper&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">Number</span> <span class="mi">5</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="p">(</span><span class="nf">Define</span>
    <span class="p">(</span><span class="nf">DefinedPredicateNode</span> <span class="s">&quot;is_prime?&quot;</span><span class="p">)</span>
    <span class="c1">; Determines whether a number supplied is prime or not</span>

    <span class="p">(</span><span class="nf">Lambda</span>
        <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>

        <span class="c1">; Call our recursive helper function</span>
        <span class="p">(</span><span class="nf">NotLink</span>
            <span class="p">(</span><span class="nf">Evaluation</span>
                <span class="p">(</span><span class="nf">DefinedPredicateNode</span> <span class="s">&quot;is_prime_helper&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="p">(</span><span class="nf">cog-evaluate!</span>
<span class="p">(</span><span class="nf">Evaluation</span>
    <span class="p">(</span><span class="nf">DefinedPredicate</span> <span class="s">&quot;is_prime?&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">Number</span> <span class="mi">37</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>



<span class="nv">BORIS,</span> <span class="nv">Include</span> <span class="nv">discussion</span> <span class="nv">about</span> <span class="nv">FFI,</span> <span class="nv">like</span> <span class="nv">a</span> <span class="nv">printf</span> <span class="nv">debug</span> <span class="nv">funcrtion</span>
</pre></div>
</div>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">scm-display-wrapper-exec</span> <span class="nv">atom</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">atom</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;done&quot;</span><span class="p">)</span>
<span class="p">)</span>

<span class="p">(</span><span class="nf">cog-execute!</span>
    <span class="p">(</span><span class="nf">ExecutionOutput</span>
        <span class="p">(</span><span class="nf">GroundedSchema</span> <span class="s">&quot;scm: scm-display-wrapper-exec&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Hi&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">scm-display-wrapper-eval</span> <span class="nv">atom</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">atom</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">stv</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>

<span class="p">(</span><span class="nf">cog-evaluate!</span>
    <span class="p">(</span><span class="nf">Evaluation</span>
        <span class="p">(</span><span class="nf">GroundedPredicate</span> <span class="s">&quot;scm: scm-display-wrapper-eval&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Hi&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">scm-display-wrapper-eval-2-arg</span> <span class="nv">atom1</span> <span class="nv">atom2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">atom1</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="nv">atom2</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">stv</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>

<span class="p">(</span><span class="nf">cog-evaluate!</span>
    <span class="p">(</span><span class="nf">Evaluation</span>
        <span class="p">(</span><span class="nf">GroundedPredicate</span> <span class="s">&quot;scm: scm-display-wrapper-eval-2-arg&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">List</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;One&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Two&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Boris end of FFI section</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">Define</span>
    <span class="c1">; Calculates the next prime number, greater than the number supplied</span>
    <span class="p">(</span><span class="nf">DefinedSchemaNode</span> <span class="s">&quot;next_prime&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">Lambda</span>
        <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;x&quot;</span><span class="p">)</span>

        <span class="c1">; temp = x+1</span>
        <span class="p">(</span><span class="nf">SetValue</span> <span class="p">(</span><span class="nf">Variable</span> <span class="s">&quot;x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;&quot;</span><span class="p">))</span>

        <span class="c1">; Check to see if temp is prime</span>

        <span class="c1">; If it is, return it, if not, recurse to find the value after temp</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>BORIS, need to explain the SetValue and ValueOf Links in Chapter 2.  It fits with the “optimization” section</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">Define</span>
    <span class="p">(</span><span class="nf">DefinedSchemaNode</span> <span class="s">&quot;list_of_n_primes&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">Lambda</span>
        <span class="p">(</span><span class="nf">VariableNode</span> <span class="s">&quot;n&quot;</span><span class="p">)</span>

    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>BORIS
Look at explaining DefinedPredicateNode</p>
<p>BORIS. Check out the <a class="reference external" href="https://github.com/opencog/atomspace/blob/master/examples/pattern-matcher/type-signature.scm">https://github.com/opencog/atomspace/blob/master/examples/pattern-matcher/type-signature.scm</a> example.
BORIS SignatureLink and DefinedTypeNode
Let’s start with data structures.  In C, for example, there is the <code class="code c docutils literal notranslate"><span class="k"><span class="pre">struct</span></span></code> keyword, to declares a collection of variables that are packaged up together as a unified code object.</p>
<p>NEXT CHAPTER BEGINS SOON.  BORIS YELTSIN</p>
<p>Intro.
We will also cover the difference between the execution and the evaluation context.</p>
<p>We’ve gotten a lot of mileage out of <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code>, but BORIS YELTSIN</p>
<p>So we saw above how we could use <code class="code docutils literal notranslate"><span class="pre">cog-evaluate!</span></code> to evaluate a atom to generate a TruthValue.
But how do we utilize that result to control what our program does next?
In other words, what are the Atomese equivalents for program-flow constructs like If-Then statements, Case statements, etc.?</p>
<p>LP: See if I can get the AndLink stuff to work for partial conditionals, testing it with the side-effect-full eval path from the recursive-loop.scm example</p>
<p>In a simple form, like this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-evaluate!</span>
    <span class="p">(</span><span class="nf">GreaterThan</span>
        <span class="p">(</span><span class="nf">Number</span> <span class="mi">10</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Number</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Notice that we’ve traded <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code> for <code class="code docutils literal notranslate"><span class="pre">cog-evaluate!</span></code>.
These OpenCog functions are similar, but where <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code> may return anything at all, <code class="code docutils literal notranslate"><span class="pre">cog-evaluate!</span></code> will always return a <em>TruthValue</em>.</p>
</div>
</div>
<div class="section" id="the-philosophy-of-truth">
<h2>The Philosophy of Truth<a class="headerlink" href="#the-philosophy-of-truth" title="Permalink to this headline">¶</a></h2>
<p>When you run that <code class="code docutils literal notranslate"><span class="pre">cog-evaluate!</span></code> snippet above, you should get this:</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">stv</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>“stv” in this case stands for <em>Simple Truth Value</em>, and an STV is composed of two floating point numbers: <em>Strength</em> and <em>Confidence</em>.
In our case, they are both exactly 1.  The expression was 100% true, and we are 100% sure of that.</p>
<p>So, as you can see, this is a step beyond simple bivalent (crisp true or false) logic in both reasoning ability and complexity.</p>
<p>But what precisely does it mean for something to be half-true?  Well… It’s complicated.</p>
<p>Consider the statement “Charlie is tall.”  If Charlie were 210cm tall, most people today would judge that true.
If he were 120cm, most would judge it false.  But what if Charlie were 175cm?  In this case, the statement might be “half-true”.</p>
<p>This line of reasoning was formalized as <a class="reference external" href="https://en.wikipedia.org/wiki/Fuzzy_logic">Fuzzy Logic</a>, by Lotfi Zadeh, whom I was lucky enough to chat with for half an hour, mostly about self-driving cars, back in the year 2000 when I was 19 years old, but I digress…</p>
<p>Using fuzzy logic, we can define a set of all tall people, and then a person with a height of 175cm could have a 50% membership in that set.
In traditional set theory, an object or data point either belongs or doesn’t belong in a set, based on the set membership function.  In other words, traditional sets always have a crisp boundary.  In fuzzy logic, the membership function returns a value between 0 and 1, so there can be a continuous transition from outside the set to inside the set.</p>
<p>But consider the conceptual difference between our statement about Charlie and the statement “The train from Birmingham arrives every day at 10:42am.”  Given the legendary unreliability of the London Midland train service, you’d certainly assign that statement a low truth value.
But this is a probabilistic truth rather than a fuzzy truth.  Some days, the train will indeed arrive on time, but on the majority of days it will not.  This kind of truth value is meant to express a probability that the statement is true.</p>
<p>So in summary, a fuzzy truth value represents the <strong>degree</strong> to which a statement is true, while a probabilistic truth value represents the <strong>chance</strong> that it is true.
Fuzzy truth values are useful for tracking, well fuzzy, statements of known facts, while probabilistic truth values are useful for tracking predictions and known uncertainties.
They are related concepts, but they aren’t mathmatically interchangeable.</p>
<p>Those are two interpretations of the <em>strength</em> component; what about the the <em>confidence</em> component?
Strength represents the known aspect of the truth value and confidence is the unknown aspect.
Consider a truth value of <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">stv</span></span> <span class="mf"><span class="pre">0.5</span></span> <span class="mf"><span class="pre">1.0</span></span><span class="p"><span class="pre">)</span></span></code> for the statement “A coin-flip will land on heads.”  If somebody offered you a bet with better-than-even odds on that coin, you could be confident that your expected return would be positive.
But consider the same statement about an unknown coin <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">stv</span></span> <span class="mf"><span class="pre">0.5</span></span> <span class="mf"><span class="pre">0.0</span></span><span class="p"><span class="pre">)</span></span></code>.  It might be a weighted coin that lands on tails 99% of the time.  From that TruthValue you just don’t know.</p>
<p>OpenCog and the Atomspace support additional types of more complicated TruthValues to cover different situations.
For example there is the <a class="reference external" href="https://wiki.opencog.org/w/FormulaTruthValue">FormulaTruthValue</a> for situations where the truth of an assertion depends on additional factors.  These are good for representing probability distribution functions.
Also there is the <a class="reference external" href="https://wiki.opencog.org/w/TruthValue#CountTruthValue">CountTruthValue</a> for situations where the system continues to collect new observations and refine its assesment of the probability.</p>
<p>Partial truth is a very big topic, and we’re not going to be able to do it justice in this guide.  This section is just a superficial introduction to make you aware of the problem-space.</p>
<p>In general, you can read the official OpenCog reference for TruthValue here: <a class="reference external" href="https://wiki.opencog.org/w/TruthValue">https://wiki.opencog.org/w/TruthValue</a></p>
<p>And now we’ll introduce <em>Probabilistic Logic Networks</em>, or <em>PLNs</em> for short.  PLNs are a way to reason with partial truth values.
OpenCog and PLNs have a shared heritage, and many ideas from PLNs deeply inform the architecture of OpenCog.  We’ll talk a lot more about PLNs in the coming chapters.</p>
<p>For now, you can read an introductory paper on PLNs here: <a class="reference external" href="https://aiatadams.files.wordpress.com/2016/02/invited_paper_3.pdf">https://aiatadams.files.wordpress.com/2016/02/invited_paper_3.pdf</a></p>
<p>And the complete PLN book can be downloaded (for now) here: <a class="reference external" href="https://aiatadams.files.wordpress.com/2016/02/pln_book_6_27_08.pdf">https://aiatadams.files.wordpress.com/2016/02/pln_book_6_27_08.pdf</a></p>
<p>BORIS HERE</p>
<p>Now, we want to put him into a “Big Dog” or a “Small Dog” set, depending on his weight.
But first, we need to define a predicate that will evaluate to true if his weight is above a threshold.</p>
<p>BORIS Unnatural Break</p>
<p>So unlike the other query link types, <code class="code docutils literal notranslate"><span class="pre">SatisfactionLink</span></code> is appropriate to use in an evaluation context rather than in an execution context.  In fact,</p>
<p>Let’s stop here, and just evaluate our new predicate.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-evaluate!</span> <span class="nv">fido_is_big?</span><span class="p">)</span>
</pre></div>
</div>
<p>You should get back <code class="code scheme docutils literal notranslate"><span class="p"><span class="pre">(</span></span><span class="nf"><span class="pre">stv</span></span> <span class="mi"><span class="pre">0</span></span> <span class="mi"><span class="pre">1</span></span><span class="p"><span class="pre">)</span></span></code>, aka false.  Fido is not heavier than 15kg.  If you’re not convinced, try tweaking Fido’s weight or the predicate to get the answer you want.</p>
<p>BORIS Unnatural Break</p>
<p>Continuing on, we can now create the appropriate <code class="code docutils literal notranslate"><span class="pre">MemberLink</span></code>, depending on how our predicate evaluates.</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-evaluate!</span>
    <span class="p">(</span><span class="nf">OrLink</span>
        <span class="p">(</span><span class="nf">AndLink</span>
            <span class="nv">fido_is_big?</span>
            <span class="p">(</span><span class="nf">MemberLink</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Fido the Dog&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;Big Dog&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">MemberLink</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Fido the Dog&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;Small Dog&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>BORIS this is BORKED.  The trouble is that those memberlinks end up existing in the atomspace BECAUSE they exist as part of the query!!!</p>
<div class="highlight-scheme notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cog-evaluate!</span>
    <span class="p">(</span><span class="nf">OrLink</span>
        <span class="p">(</span><span class="nf">AndLink</span>
            <span class="nv">fido_is_big?</span>
            <span class="p">(</span><span class="nf">StateLink</span>
                <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Fido the Dog&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;Big Dog&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="p">(</span><span class="nf">StateLink</span>
            <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Fido the Dog&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;Small Dog&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>


<span class="p">(</span><span class="nf">cog-evaluate!</span>
    <span class="p">(</span><span class="nf">MemberLink</span> <span class="p">(</span><span class="nf">stv</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Concept</span> <span class="s">&quot;Fido the Dog&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">Predicate</span> <span class="s">&quot;Small Dog&quot;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>BORIS, talk about how both sides can potentially execute, and it’s just up to the end to decide which side to use.  How there isn’t a program counter, as in precedural programming.</p>
<p>Boris, what happens if something has a truth value of 0.5???  Which link is created???  Both.</p>
<p>BORIS YELTSIN
Talk about side-effect-free vs. side-effects, SequentialAndLink</p>
<p>BORIS introduce StrengthOf &amp; CondfidenceOf</p>
</div>
<div class="section" id="declaring-evaluationlinks">
<h2>Declaring EvaluationLinks<a class="headerlink" href="#declaring-evaluationlinks" title="Permalink to this headline">¶</a></h2>
<p>BORIS, talk about grounding and checking if an assertion is true or not</p>
<p>Assert, (Come up with an example that isn’t an “isa” relationship.  Dogs chew bones, goats chew leaves)</p>
<p>BORIS Below is WRONG!
In the previous chapter, we showed how <code class="code docutils literal notranslate"><span class="pre">cog-execute!</span></code> could execute certain <em>Active</em> links, resulting in an atom or value being created and returned.
For <em>Declarative</em>, aka passive links, the <code class="code docutils literal notranslate"><span class="pre">cog-evaluate!</span></code> OpenCog function is its counterpart.
Unlike Active Links, Declarative links always evaluate to a <em>TruthValue</em>.</p>
<p>BORIS, include the fact that a truthValue is attached to an atom with a special key.  Explained in values.scm example.</p>
<p>BORIS Let’s ask the Atomspace a true/false question.  “Is Fido an Animal?”</p>
<p>BORIS What to say about EvaluationLink??  We’ve already introduced them above, GreaterThanLink is an EvalLink.</p>
<p>BORIS.  Explain AnchorNodes and VariableLists</p>
<p>BORIS Revisit PredicateNode</p>
<p>BORIS EvaluationLink
BORIS two views, as an assertion with a truth value, or as a way to evaluate the truth of a proposition</p>
<p>BORIS BORIS, How do I query whether something is part of another set</p>
<p>BORIS PredicateFOrmula</p>
<p>BORIS Cover using PutLink to find a location and update it.  For example, search the Atomspace, and put all dogs heavier than 10kg is the “Big Dogs” set.</p>
<p>BORIS (CAN I DEFINE MY OWN TYPES, from an atom-uniqueness standpoint???)
BORIS Next Chapter
We’ll also talk about the FFI, like using ExecutionOutput and GroundedSchema, or GroundedPredicate, look at “execute.scm”</p>
<p>BORIS.  Understand how Values become Atoms sometimes…  A clue is dropped in the documentation on SleepLink <a class="reference external" href="https://wiki.opencog.org/w/SleepLink">https://wiki.opencog.org/w/SleepLink</a>
He says “NumberNodes are problematic for the AtomSpace”.  It appears that numeric values can exist temporarily, and under certain situations then crystalize into nodes.  Hippo has something similar.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Luke's Atomspace Quickstart Guide</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="01_getting_oriented.html">Getting Oriented &amp; Basic Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_representing_knowledge.html">Structured Knowledge &amp; Simple Queries</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Programming with Atomese</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#conditional-expressions">Conditional Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-putlink-to-modify-the-atomspace">Using PutLink to Modify the AtomSpace</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ungrounded-expressions-can-represent-latent-code">Ungrounded Expressions can Represent “Latent Code”</a></li>
<li class="toctree-l3"><a class="reference internal" href="#grounding-a-deletelink-removes-an-atom">Grounding a DeleteLink Removes an Atom</a></li>
<li class="toctree-l3"><a class="reference internal" href="#finding-atoms-with-a-query-inside-a-putlink">Finding Atoms with a Query Inside a PutLink</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#defines-schemas-lambdas-and-functions-in-atomese">Defines, Schemas, Lambdas and Functions in Atomese</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basic-subroutines">Basic Subroutines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lambdalink-lets-you-pass-function-arguments">LambdaLink Lets you Pass Function Arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#typed-variables-and-variablelists-as-arguments">Typed Variables and VariableLists as Arguments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#looping-with-tail-recursion">Looping with Tail Recursion</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#local-variables">Local Variables</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-philosophy-of-truth">The Philosophy of Truth</a></li>
<li class="toctree-l2"><a class="reference internal" href="#declaring-evaluationlinks">Declaring EvaluationLinks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="04_logical_inferencing.html">Logical Inferencing</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="02_representing_knowledge.html" title="previous chapter">Structured Knowledge &amp; Simple Queries</a></li>
      <li>Next: <a href="04_logical_inferencing.html" title="next chapter">Logical Inferencing</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Luke Peterson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/contents/03_atomese_programming.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>